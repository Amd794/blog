<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>性能 on cmdragon's Blog</title><link>/tags/%E6%80%A7%E8%83%BD/</link><description>Recent content in 性能 on cmdragon's Blog</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Fri, 06 Dec 2024 00:18:53 +0800</lastBuildDate><atom:link href="/tags/%E6%80%A7%E8%83%BD/index.xml" rel="self" type="application/rss+xml"/><item><title>Nuxt.js 应用中的 afterResponse 事件钩子</title><link>/posts/0099146574320c07d4d7bae1b6b526e4/</link><pubDate>Fri, 06 Dec 2024 00:18:53 +0800</pubDate><guid>/posts/0099146574320c07d4d7bae1b6b526e4/</guid><description>在 Web 应用程序中，响应的后续处理是提升用户体验，进行数据分析和监控的重要组成部分。Nuxt.js 提供的 afterResponse 钩子允许开发者在发送响应之后实施自定义操作，这一机制有助于进行任务如记录日志、监控性能等。</description></item><item><title>Nuxt.js 应用中的 beforeResponse 事件钩子</title><link>/posts/a53897bbc3efd267f867b8ad06770144/</link><pubDate>Thu, 05 Dec 2024 00:18:53 +0800</pubDate><guid>/posts/a53897bbc3efd267f867b8ad06770144/</guid><description>在 Web 开发中，处理响应是一个至关重要的环节。Nuxt.js 提供的 beforeResponse 钩子允许开发者在发送响应之前对结果进行修改或处理。这一机制非常有助于确保返回给客户端的数据格式、内容以及响应头等符合特定需求，从而提升用户体验和系统的稳定性。</description></item><item><title>Nuxt.js 应用中的 request 事件钩子</title><link>/posts/d821e2e0d8af1f6e0a02aa2f6cddf24e/</link><pubDate>Wed, 04 Dec 2024 00:18:53 +0800</pubDate><guid>/posts/d821e2e0d8af1f6e0a02aa2f6cddf24e/</guid><description>在构建现代 Web 应用时，处理请求是核心内容之一。无论是从后端获取数据，还是处理用户请求、验证和授权，正确地处理请求能够确保应用的稳定性、可维护性和用户体验。Nuxt.js 提供了 request 钩子，允许开发者在接收到请求时进行自定义处理，这为复杂应用提供了极大的灵活性。</description></item><item><title>Nuxt.js 应用中的 vite：compiled 事件钩子</title><link>/posts/11098eb685e9bd4009275da31c80ae6d/</link><pubDate>Tue, 19 Nov 2024 00:18:53 +0800</pubDate><guid>/posts/11098eb685e9bd4009275da31c80ae6d/</guid><description>在 Nuxt 3 中，vite:compiled 钩子允许开发者在 Vite 编译完成后执行自定义逻辑。通过这个钩子，开发者可以在代码编译完成后进行一些必要的处理，比如输出编译状态、更新 UI 或触发其他事件。</description></item><item><title>使用 nuxi generate 进行预渲染和部署</title><link>/posts/82f081b254205e6c18a5d415f97f2519/</link><pubDate>Wed, 04 Sep 2024 00:18:53 +0800</pubDate><guid>/posts/82f081b254205e6c18a5d415f97f2519/</guid><description>通过 nuxi generate 命令，你可以轻松地将 Nuxt 应用程序预渲染为静态 HTML 文件，并将其部署到任何静态托管服务。这种方法可以提高应用程序的性能和安全性，特别适用于那些需要快速加载的应用。</description></item><item><title>使用 preloadRouteComponents 提升 Nuxt 应用的性能</title><link>/posts/476d81c3a7972e5b8d84db523437836c/</link><pubDate>Mon, 19 Aug 2024 00:18:53 +0800</pubDate><guid>/posts/476d81c3a7972e5b8d84db523437836c/</guid><description>preloadRouteComponents 是提升 Nuxt 应用性能的一个简单而有效的工具。通过在适当的时候预加载路由组件，你可以为用户提供更快速、更流畅的导航体验。</description></item><item><title>使用 preloadComponents 进行组件预加载</title><link>/posts/b54b94bb4434e506c17b07f68a13bf94/</link><pubDate>Sun, 18 Aug 2024 00:18:53 +0800</pubDate><guid>/posts/b54b94bb4434e506c17b07f68a13bf94/</guid><description>摘要：本文介绍Nuxt 3中的preloadComponents功能，用于预加载全局注册的组件以减少首次渲染阻塞时间，通过实例演示如何设置并使用该工具来提升页面性能。</description></item><item><title>使用 useNuxtData 进行高效的数据获取与管理</title><link>/posts/5097e3f618f180282a847588006a51d8/</link><pubDate>Mon, 22 Jul 2024 00:18:53 +0800</pubDate><guid>/posts/5097e3f618f180282a847588006a51d8/</guid><description>深入讲解了Nuxt 3中useNuxtData组合函数的应用，演示了如何通过此函数访问缓存数据，实现组件间数据共享，以及如何在数据更新时利用缓存提高用户体验。文章提供了具体的用法示例，包括数据获取、访问缓存数据和数据更新的场景。</description></item><item><title>Vue 3 Teleport：掌控渲染的艺术</title><link>/posts/fd87cbf08f2b3ceca1e00cdb0bb4b2b0/</link><pubDate>Wed, 05 Jun 2024 00:18:53 +0800</pubDate><guid>/posts/fd87cbf08f2b3ceca1e00cdb0bb4b2b0/</guid><description>这篇文章介绍了Vue3框架中的一个创新特性——Teleport，它允许开发者将组件内容投送到文档对象模型（DOM）中的任意位置，即使这个位置在组件的挂载点之外。Teleport旨在解决某些特定场景下的布局和嵌套问题，如 modal 对话框、弹出框或注入全局头部等。通过使用Teleport，可以更灵活地管理这些特殊组件，同时保持应用程序结构的清晰。文章可能会详细讲解Teleport的工作原理、使用方法及其对应用性能和测试的影响。</description></item><item><title>Django信号与扩展：深入理解与实践</title><link>/posts/13ce298742c5b544510b64df767a9f23/</link><pubDate>Wed, 15 May 2024 22:40:52 +0800</pubDate><guid>/posts/13ce298742c5b544510b64df767a9f23/</guid><description>&lt;h2 id="第一部分django信号基础">第一部分：Django信号基础&lt;/h2>
&lt;h3 id="django信号概述">Django信号概述&lt;/h3>
&lt;p>一. Django信号的定义与作用&lt;/p>
&lt;p>Django信号（Signal）是Django框架中的一种机制，用于在特定事件发生时进行通信。信号可以让不同的Django组件松耦合地通信，即使它们不直接相互依赖。这种松耦合的设计使得Django应用更加灵活、可扩展和可维护。&lt;/p></description></item><item><title>深入理解Django：中间件与信号处理的艺术</title><link>/posts/2754fe06b895a4268f93c63424bd4c13/</link><pubDate>Thu, 09 May 2024 18:41:21 +0800</pubDate><guid>/posts/2754fe06b895a4268f93c63424bd4c13/</guid><description>&lt;img src="/images/2024_05_09 18_45_49.png" title="2024_05_09 18_45_49.png" alt="2024_05_09 18_45_49.png"/>
&lt;h2 id="引言">&lt;strong>引言&lt;/strong>&lt;/h2>
&lt;p>在当今的Web开发领域，Django以其强大的功能、简洁的代码结构和高度的可扩展性，已成为众多开发者的首选框架。Django不仅是一个内容管理系统，更是一个全面的框架，它提供了一套完整的解决方案，包括ORM、模板引擎、URL路由系统和强大的管理后台，使得开发者能够快速构建高质量的Web应用。&lt;/p></description></item></channel></rss>