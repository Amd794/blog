<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TypeScript on cmdragon's Blog</title><link>/tags/TypeScript/</link><description>Recent content in TypeScript on cmdragon's Blog</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Fri, 08 Nov 2024 00:18:53 +0800</lastBuildDate><atom:link href="/tags/TypeScript/index.xml" rel="self" type="application/rss+xml"/><item><title>Nuxt.js 应用中的 prepare：types 事件钩子详解</title><link>/posts/68419c6dd94db64cbb46673ab19a5146/</link><pubDate>Fri, 08 Nov 2024 00:18:53 +0800</pubDate><guid>/posts/68419c6dd94db64cbb46673ab19a5146/</guid><description>prepare:types 钩子为 Nuxt.js 开发者提供了灵活定制 TypeScript 配置和声明的能力。通过使用此钩子，开发者能够确保 TypeScript 配置和类型声明能够满足他们的项目需求，提升代码的可维护性和类型安全性。</description></item><item><title>Nuxt Kit 中的插件：创建与使用</title><link>/posts/cb753641cae33519dd339d523c5afa32/</link><pubDate>Thu, 19 Sep 2024 00:18:53 +0800</pubDate><guid>/posts/cb753641cae33519dd339d523c5afa32/</guid><description>摘要：本文介绍了在 Nuxt 3 框架中使用 Nuxt Kit 创建和管理插件的方法，包括使用addPlugin注册插件、创建插件文件、在Vue组件中使用插件，以及使用addPluginTemplate创建插件模板和动态生成插件代码。</description></item><item><title>Nuxt Kit 的使用指南：从加载到构建</title><link>/posts/a19304accfa8f913a68caae99dfa8a68/</link><pubDate>Thu, 12 Sep 2024 00:18:53 +0800</pubDate><guid>/posts/a19304accfa8f913a68caae99dfa8a68/</guid><description>摘要：本文详细介绍了Nuxt Kit的使用方法，包括如何使用loadNuxt加载配置、buildNuxt进行项目构建、loadNuxtConfig单独加载配置以及writeTypes生成TypeScript配置，旨在帮助前端开发者高效地以编程方式管理和交互Nuxt应用。</description></item><item><title>如何在 Nuxt 3 中有效使用 TypeScript</title><link>/posts/3121b9f162f334cf3f36524ef4a0a21c/</link><pubDate>Mon, 09 Sep 2024 00:18:53 +0800</pubDate><guid>/posts/3121b9f162f334cf3f36524ef4a0a21c/</guid><description>摘要：本文详细介绍了如何在Nuxt 3项目中有效使用TypeScript，包括创建新项目、安装TypeScript依赖、进行类型检查、配置自动类型检查、使用自动生成的类型文件、实现更严格的类型检查、创建及使用TypeScript组件等步骤，旨在提升开发效率和代码质量</description></item><item><title>Nuxt.js 环境变量配置与使用</title><link>/posts/53eb62f578931146081c71537fd0c013/</link><pubDate>Thu, 25 Jul 2024 00:18:53 +0800</pubDate><guid>/posts/53eb62f578931146081c71537fd0c013/</guid><description>摘要：“该文探讨了Nuxt.js框架下环境变量配置的详细过程，涉及.env文件配置、运行时访问、安全性考量、在不同场景下的实践（如Vue应用、插件、服务器路由）及多环境配置下的最佳实践。”</description></item><item><title>Nuxt3 的生命周期和钩子函数（八）</title><link>/posts/627bff83be4d55aabeccd96fdb6bab35/</link><pubDate>Sun, 30 Jun 2024 00:18:53 +0800</pubDate><guid>/posts/627bff83be4d55aabeccd96fdb6bab35/</guid><description>摘要：本文介绍了Nuxt3框架中的一些重要生命周期钩子，如prepare:types用于自定义TypeScript配置和类型声明，listen用于在开发服务器启动时注册自定义事件监听器，schema:extend和schema:resolved用于扩展和处理已解析的模式，以及schema:beforeWrite和schema:written分别在模式写入前后的处理。通过示例代码展示了如何在Nuxt插件中利用这些钩子进行自定义操作。</description></item><item><title>掌握 Nuxt 3 中的状态管理：实践指南</title><link>/posts/ad69660187283f1e8c3089b30d86704e/</link><pubDate>Sat, 22 Jun 2024 00:18:53 +0800</pubDate><guid>/posts/ad69660187283f1e8c3089b30d86704e/</guid><description>摘要：该文指南详述了Nuxt 3的概况与安装，聚焦于在Nuxt 3框架下运用Vuex进行高效的状态管理，涵盖基础配置、模块化实践至高阶策略，助力开发者构建高性能前后端分离应用。</description></item><item><title>Vue TypeScript 实战：掌握静态类型编程</title><link>/posts/5fd5f7ddeea4d0fcae77f0c558181bc2/</link><pubDate>Mon, 10 Jun 2024 00:18:53 +0800</pubDate><guid>/posts/5fd5f7ddeea4d0fcae77f0c558181bc2/</guid><description>这篇文章介绍了如何在TypeScript环境下为Vue.js应用搭建项目结构，包括初始化配置、创建Vue组件、实现状态管理利用Vuex、配置路由以及性能优化的方法，旨在提升开发效率与应用性能。</description></item><item><title>理解Vue 3响应式系统原理</title><link>/posts/12ece7efaa9c31de1f58457b847bb1ce/</link><pubDate>Tue, 28 May 2024 15:44:47 +0800</pubDate><guid>/posts/12ece7efaa9c31de1f58457b847bb1ce/</guid><description>&lt;img src="/images/2024_05_28 15_46_34.png" title="2024_05_28 15_46_34.png" alt="2024_05_28 15_46_34.png"/>
&lt;h2 id="第一章vue-3简介">第一章：Vue 3简介&lt;/h2>
&lt;h3 id="11-vue-3概述">1.1 Vue 3概述&lt;/h3>
&lt;ul>
&lt;li>Vue 3的诞生背景：Vue 2的局限与改进需求&lt;/li>
&lt;li>Vue 3的主要版本发布日期和目标：稳定性和性能的提升&lt;/li>
&lt;/ul>
&lt;h3 id="12-vue-3的新特性">1.2 Vue 3的新特性&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>TypeScript支持&lt;/strong>：引入TypeScript作为官方推荐的开发语言，增强了类型安全性和代码质量。&lt;/li>
&lt;li>&lt;strong>SFC（Single File Component）的优化&lt;/strong>：更简洁的语法，如引入模板片段、JSX支持，以及更灵活的组件结构。&lt;/li>
&lt;li>&lt;strong>Composition API&lt;/strong>：取代options API，提供更模块化、可组合的组件开发方式。&lt;/li>
&lt;li>&lt;strong>Ref和Reactive&lt;/strong>：新的数据管理方式，ref用于直接操作原始值，而reactive用于创建响应式对象。&lt;/li>
&lt;li>&lt;strong>虚拟DOM的优化&lt;/strong>：Vue 3使用新的编译器，提升了性能，特别是在大型应用和复杂组件中的渲染速度。&lt;/li>
&lt;li>&lt;strong>服务插槽（Slots as Functions）&lt;/strong> ：提供更灵活的插槽管理，简化组件间通信。&lt;/li>
&lt;li>&lt;strong>SSR（Server-Side Rendering）&lt;/strong> ：支持更高效的服务器渲染，提升了SEO和性能。&lt;/li>
&lt;/ul>
&lt;h3 id="13-vue-3的架构设计">1.3 Vue 3的架构设计&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Vue 3的核心组件&lt;/strong>：Vue实例、模板编译器、响应式系统的核心组成部分。&lt;/li>
&lt;li>&lt;strong>组件化设计&lt;/strong>：如何通过Composition API构建可复用、可组合的组件。&lt;/li>
&lt;li>&lt;strong>可扩展性&lt;/strong>：Vue 3如何保持开放性和可扩展性，包括插件系统和第三方库的兼容性。&lt;/li>
&lt;li>&lt;strong>社区和生态系统&lt;/strong>：Vue 3的社区活跃度，以及生态系统中提供的各种工具和库。&lt;/li>
&lt;/ul>
&lt;h2 id="第二章响应式系统概述">第二章：响应式系统概述&lt;/h2>
&lt;h3 id="21-响应式系统的定义">2.1 响应式系统的定义&lt;/h3>
&lt;ul>
&lt;li>响应式系统：是一种数据绑定机制，在数据模型变化时，自动更新视图。&lt;/li>
&lt;li>在Vue中，响应式系统基于数据劫持和发布-订阅模式实现。&lt;/li>
&lt;/ul>
&lt;h3 id="22-响应式系统的优势">2.2 响应式系统的优势&lt;/h3>
&lt;ul>
&lt;li>自动同步数据和视图：开发人员无需手动更新视图，提高开发效率和代码可维护性。
AD：&lt;a href="https://comic.cmdragon.cn:2087/">漫画首页&lt;/a>&lt;/li>
&lt;li>高性能：通过数据劫持和Diff算法，在数据更新时仅更新必要的DOM元素，减少重绘和回流。&lt;/li>
&lt;/ul>
&lt;h3 id="23-vue-3响应式系统的特点">2.3 Vue 3响应式系统的特点&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Proxy vs Object.defineProperty&lt;/strong>：Vue 3使用Proxy代替Object.defineProperty，解决了Object.defineProperty的局限性，如只能监听对象的属性，而不能监听整个对象。&lt;/li>
&lt;li>&lt;strong>Ref和Reactive&lt;/strong>：Vue 3中，ref用于直接操作原始值，而reactive用于创建响应式对象，提供更灵活的数据管理方式。&lt;/li>
&lt;li>&lt;strong>响应式系统的API&lt;/strong>：Vue 3提供了一系列API，用于管理和操作响应式数据，如、𝑠𝑒𝑡、delete、$watch等。&lt;/li>
&lt;/ul>
&lt;h2 id="第三章响应式系统的实现原理">第三章：响应式系统的实现原理&lt;/h2>
&lt;h3 id="31-数据劫持">3.1 数据劫持&lt;/h3>
&lt;ul>
&lt;li>数据劫持是响应式系统的核心机制之一，它通过拦截对象属性的读取和设置操作，实现对数据的监控。&lt;/li>
&lt;li>在Vue 2中，数据劫持主要通过&lt;code>Object.defineProperty&lt;/code>实现，而在Vue 3中，则使用&lt;code>Proxy&lt;/code>对象来实现更强大的数据劫持功能。&lt;/li>
&lt;li>&lt;code>Proxy&lt;/code>可以监听对象的任何属性变化，包括新增和删除属性，而&lt;code>Object.defineProperty&lt;/code>只能监听已存在的属性。&lt;/li>
&lt;/ul>
&lt;h3 id="32-依赖收集">3.2 依赖收集&lt;/h3>
&lt;ul>
&lt;li>依赖收集是指在数据被读取时，记录哪些组件或代码依赖于该数据。这样，当数据变化时，可以精确地通知到依赖它的组件或代码。&lt;/li>
&lt;li>Vue使用Watcher对象来收集依赖。当组件渲染时，会创建一个Watcher实例，该实例会读取响应式数据，从而触发数据的getter，进而将Watcher添加到依赖列表中。&lt;/li>
&lt;/ul>
&lt;h3 id="33-派发更新">3.3 派发更新&lt;/h3>
&lt;ul>
&lt;li>派发更新是指在数据变化时，通知所有依赖该数据的Watcher进行更新。&lt;/li>
&lt;li>在Vue中，当数据被修改时，会触发setter，进而触发依赖列表中的所有Watcher的更新函数，使得依赖该数据的组件重新渲染。&lt;/li>
&lt;li>Vue 3通过引入&lt;code>effect&lt;/code>函数和&lt;code>scheduler&lt;/code>调度器，优化了派发更新的过程，可以更细粒度地控制更新时机，减少不必要的渲染。&lt;/li>
&lt;/ul>
&lt;h2 id="第四章响应式系统的核心api">第四章：响应式系统的核心API&lt;/h2>
&lt;h3 id="41-reactive">4.1 reactive&lt;/h3>
&lt;ul>
&lt;li>&lt;code>reactive&lt;/code>函数是Vue 3中用于创建响应式对象的API。&lt;/li>
&lt;li>它接受一个对象作为参数，返回一个响应式的对象。&lt;/li>
&lt;li>响应式对象的所有属性都会被自动转换为响应式的，且可以通过&lt;code>ref&lt;/code>或&lt;code>reactive&lt;/code>创建的响应式对象是“嵌套”的，即内部的对象也是响应式的。&lt;/li>
&lt;li>使用&lt;code>reactive&lt;/code>时，推荐用于对象类型数据，尤其是当对象层次较深时。&lt;/li>
&lt;/ul>
&lt;h3 id="42-ref">4.2 ref&lt;/h3>
&lt;ul>
&lt;li>&lt;code>ref&lt;/code>函数是Vue 3中用于创建响应式基本数据的API。&lt;/li>
&lt;li>它接受一个基本类型（如字符串、数字、布尔值等）或对象类型参数，返回一个响应式的引用对象。AD：&lt;a href="https://cmdragon.cn/">首页 | 一个覆盖广泛主题工具的高效在线平台&lt;/a>&lt;/li>
&lt;li>响应式引用对象有一个&lt;code>.value&lt;/code>属性，用于访问或修改内部的数据。&lt;/li>
&lt;li>使用&lt;code>ref&lt;/code>时，推荐用于基本类型数据，尤其是当数据变化不复杂时。&lt;/li>
&lt;/ul>
&lt;h3 id="43-computed">4.3 computed&lt;/h3>
&lt;ul>
&lt;li>&lt;code>computed&lt;/code>函数是Vue 3中用于创建计算属性的API。&lt;/li>
&lt;li>它接受一个函数作为参数，该函数返回一个计算结果。&lt;/li>
&lt;li>计算属性是基于其依赖项的响应式数据自动更新的。&lt;/li>
&lt;li>当依赖项中的数据发生变化时，计算属性会重新计算并返回新的结果。&lt;/li>
&lt;li>计算属性适合用于复杂的逻辑计算和数据处理。&lt;/li>
&lt;/ul>
&lt;h3 id="44-watch">4.4 watch&lt;/h3>
&lt;ul>
&lt;li>&lt;code>watch&lt;/code>函数是Vue 3中用于侦听响应式数据变化的API。&lt;/li>
&lt;li>它接受一个需要侦听的数据（或计算属性）作为参数，以及一个回调函数。&lt;/li>
&lt;li>当侦听的数据发生变化时，回调函数会被执行。&lt;/li>
&lt;li>&lt;code>watch&lt;/code>可以用于侦听单个数据或多个数据的变化。&lt;/li>
&lt;li>侦听器可以提供额外的选项，如&lt;code>deep&lt;/code>（深度监听）、&lt;code>immediate&lt;/code>（立即执行回调）等。&lt;/li>
&lt;/ul>
&lt;h2 id="第五章响应式系统的优化">第五章：响应式系统的优化&lt;/h2>
&lt;h3 id="51-静态提升static-optimization">5.1 静态提升（Static Optimization）&lt;/h3>
&lt;ul>
&lt;li>Vue 3通过“静态提升”（SFC Shallow Rendering）来优化初始渲染性能。当组件首次渲染时，Vue 会尝试仅渲染组件的顶层模板，而不是递归渲染所有嵌套的组件。这减少了初始渲染时的DOM操作和计算，特别是对于大型组件树，能显著提升性能。&lt;/li>
&lt;/ul>
&lt;h3 id="52-事件监听缓存event-listener-caching">5.2 事件监听缓存（Event Listener Caching）&lt;/h3>
&lt;ul>
&lt;li>Vue 通过事件监听缓存来优化事件处理。当一个组件实例创建时，它会缓存特定类型的事件处理器，而不是每次事件触发时都重新创建。这减少了事件处理函数的创建和销毁，特别是在频繁触发的事件中，可以显著减少性能开销。&lt;/li>
&lt;/ul>
&lt;h3 id="53-响应式对象的优化">5.3 响应式对象的优化&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Vue 3的响应式系统对于数据的依赖跟踪和更新是高效的，但也可能存在一些优化点：&lt;/p></description></item><item><title>在前端开发项目中整合配置 Prettier 和 ESLint</title><link>/posts/33ce05adf3c0a1a7228901f9f265dedb/</link><pubDate>Sun, 04 Feb 2024 01:55:24 +0800</pubDate><guid>/posts/33ce05adf3c0a1a7228901f9f265dedb/</guid><description>&lt;p>引言：
在前端开发中，代码的格式化和规范是非常重要的。Prettier和ESLint是两个常用的工具，可以帮助我们自动格式化代码和检查代码规范。本文将介绍如何在前端开发项目中整合和配置Prettier和ESLint，以提高代码质量和开发效率。&lt;/p></description></item></channel></rss>