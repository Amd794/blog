<!DOCTYPE html><html lang=zh-CN,zh-TW,en,default><head><meta charset=utf-8><link href=/images/favicon.ico rel=icon><link rel=apple-touch-icon href=/images/apple-touch-icon.png><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=keywords content=" 协程, 异步IO, 并发编程, Python, aiohttp, asyncio, 网络爬虫, cmdragon, 个人网站, 编程, 技术分享, 学习资源, 前端开发, 后端开发, 全栈开发, 编程语言, 开发者社区"><meta name=description content="cmdragon’s Blog 是一个专注于编程和技术分享的个性化网站，旨在为编程爱好者、学习者和从业者提供全面的前端开发、后端开发以及全栈开发学习资源。在这里，你可以深入了解各种编程语言，探索实用的技术技巧，还能与其他开发者共同交流，助力个人技能提升和职业发展。"><meta name=author content=cmdragon><meta name=baidu-site-verification content=codeva-Q85hVj3vOu><link rel=alternate type=application/atom+xml href=https://blog.cmdragon.cn/atom.xml><link rel=alternate type=application/rss+xml href=https://blog.cmdragon.cn/sitemap.xml><meta property=og:url content=https://blog.cmdragon.cn/2024/04/27/back_end/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3python%E5%8D%8F%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98/index.html><meta property=og:type content=website><meta property=og:title content="深入理解Python协程：从基础到实战 - cmdragon’s Blog"><meta property=og:description content="深入理解Python协程：从基础到实战, cmdragon’s Blog 是一个专注于编程和技术分享的个性化网站，旨在为编程爱好者、学习者和从业者提供全面的前端开发、后端开发以及全栈开发学习资源。在这里，你可以深入了解各种编程语言，探索实用的技术技巧，还能与其他开发者共同交流，助力个人技能提升和职业发展。"><meta property=og:image content=https://api.btstu.cn/sjbz/api.php><meta name=twitter:card content=https://api.btstu.cn/sjbz/api.php><meta property=twitter:domain content=cmdragon.cn><meta property=twitter:url content=https://blog.cmdragon.cn/2024/04/27/back_end/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3python%E5%8D%8F%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98/index.html><meta name=twitter:title content="深入理解Python协程：从基础到实战 - cmdragon’s Blog"><meta name=twitter:description content="深入理解Python协程：从基础到实战, cmdragon’s Blog 是一个专注于编程和技术分享的个性化网站，旨在为编程爱好者、学习者和从业者提供全面的前端开发、后端开发以及全栈开发学习资源。在这里，你可以深入了解各种编程语言，探索实用的技术技巧，还能与其他开发者共同交流，助力个人技能提升和职业发展。"><meta name=twitter:image content=https://api.btstu.cn/sjbz/api.php><script type=text/javascript>((t,e,n,a,c,r)=>{t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(c=e.createElement(a)).async=1,c.src="https://www.clarity.ms/tag/mmt9qkvlod",(r=e.getElementsByTagName(a)[0]).parentNode.insertBefore(c,r)})(window,document,"clarity","script")</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2874982874195135" crossorigin=anonymous></script><script charset=UTF-8 id=LA_COLLECT src=//sdk.51.la/js-sdk-pro.min.js></script><script>LA.init({id:"3IdZIMuyj5mvN0Fz",ck:"3IdZIMuyj5mvN0Fz"})</script><meta name=baidu-site-verification content=codeva-1e6idrc8FW><script>(()=>{var e,t,o,r,n=document.getElementsByTagName("link");if(0<n.length)for(i=0;i<n.length;i++)"canonical"==n[i].rel.toLowerCase()&&n[i].href&&(e=n[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,r=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",r?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)})()</script><title>深入理解Python协程：从基础到实战 | cmdragon&#39;s Blog</title><script type=application/ld+json>{
            "@context": "https://schema.org",
            "@type": "NewsArticle",
            "headline": "深入理解Python协程：从基础到实战 - cmdragon’s Blog",
            "image": [
                "https://api.btstu.cn/sjbz/api.php",
                "https://t.alcy.cc/mp/",
                "https://img.xjh.me/random_img.php"
            ],
            "datePublished": "Sat Apr 27 2024 16:48:43 GMT+0800",
            "dateModified": "Sat Apr 27 2024 16:48:43 GMT+0800",
            "aggregateRating": {
                "@type": "AggregateRating",
                "itemReviewed": {
                    "type": "Book",
                    "name": "深入理解Python协程：从基础到实战 - cmdragon’s Blog"
                },
                "ratingValue": 9.5,
                "bestRating": "10",
                "ratingCount": 526
            },
            "publisher":
              {
                    "@type": "Person",
                    "name": "cmdragon",
                    "url": "https://github.com/Amd794"
              },
            "author": [
                {
                    "@type": "Person",
                    "name": "cmdragon",
                    "url": "https://cmdragon.cn/"
                },
                {
                    "@type": "Person",
                    "name": "amd794",
                    "url": "https://github.com/Amd794"
                }
            ]
        }</script><script>(()=>{var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js",(e=document.getElementsByTagName("script")[0]).parentNode.insertBefore(t,e)})()</script><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/images/favicon.ico><link rel=stylesheet href=/font/css/fontawesome.min.css><link rel=stylesheet href=/font/css/regular.min.css><link rel=stylesheet href=/font/css/solid.min.css><link rel=stylesheet href=/font/css/brands.min.css><script class=keep-theme-configurations>let KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"blog.cmdragon.cn",root:"/",language:["zh-CN","zh-TW","en","default"],path:"search.json"},KEEP.theme_config={base_info:{primary_color:"#0066cc",title:"cmdragon's Blog",author:"cmdragon",avatar:"/images/avatar.jpg",logo:"/images/logo.svg",favicon:"/images/favicon.ico",apple_touch_icon:"/images/apple-touch-icon.png"},menu:{Home:"/",Archives:"/archives","工具箱":"https://tools.cmdragon.cn",Links:"/links"},first_screen:{enable:!0,background_img:"/images/bg.svg",background_img_dark:"/images/bg.svg",description:"Keep writing and Keep loving.",hitokoto:!0},social_contact:{enable:!0,links:null},scroll:{progress_bar:!0,hide_header:!0},home:{category:!1,tag:!0},post:{author_badge:{enable:!0,level_badge:!1,custom_badge:["炼气","筑基","结丹","元婴","化神","破虚","渡劫","大乘","散仙","真仙","金仙","玄仙","天仙","圣人"]},word_count:{wordcount:!0,min2read:!0},datetime_format:"YYYY-MM-DD HH:mm:ss",copyright_info:!0,share:!0,reward:{enable:!0,img_link:"/images/payment.jpg",text:"打赏作者一包辣条！"}},code_block:{tools:{enable:!0,style:"default"},highlight_theme:"default"},toc:{enable:!0,number:!0,expand_all:!0,init_open:!0,layout:"right"},local_search:{enable:!0,preload:!0},comment:{enable:!1},rss:{enable:!0},lazyload:{enable:!0},cdn:{enable:!1,provider:"cdnjs"},footer:{since:2023,word_count:!1,record:{enable:!1,list:[{code:"粤ICP备2024258322号-2",link:"https://beian.miit.gov.cn"}]},site_deploy:{enable:!0,provider:"github",url:"https://tools.cmdragon.cn/"}},mermaid:{enable:!0,version:"latest"},root:"",source_data:{icons:{"赞赏":{svg:'<svg t="1706412189860" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3855" width="200" height="200"><path d="M984 632.9l-0.2 0.2C953.9 522 885.5 425.4 791.3 360.3c-13.9-9.6-32-10.5-47.8-4.4-150.4 58.7-317.4 58.7-467.7 0-15.8-6.2-33.8-5.2-47.7 4.4C65.4 473.3-12 675.6 35.7 869.7 65 947.3 136.4 1001.2 219 1008.1h594.6c59.8-1.5 115-32.7 147.1-83.2 18-24.9 28.3-54.5 29.8-85.2 15.9-68.3 13.7-139.6-6.5-206.8zM632.4 795h-91.7v61.7c0 16.4-13.3 29.8-29.8 29.8-16.4 0-29.8-13.3-29.8-29.8V795h-91.6c-16.4 0-29.8-13.3-29.8-29.8 0-16.4 13.3-29.8 29.8-29.8h91.6v-61.8h-91.6c-16.4 0-29.8-13.3-29.8-29.8 0-16.4 13.3-29.8 29.8-29.8H447l-68.2-68.2c-8.1-7.5-11.4-18.8-8.7-29.5 2.7-10.7 11.1-19 21.7-21.7 10.7-2.7 22 0.6 29.5 8.7l85.2 85.2 85.2-85.2c11.9-11 30.4-10.7 41.8 0.7 11.5 11.5 11.8 29.9 0.8 41.8L570.4 614h61.7c16.4 0 29.8 13.3 29.8 29.8 0 16.4-13.3 29.8-29.8 29.8h-91.9v61.7h92c16.4 0 29.8 13.3 29.8 29.8 0.2 16.6-13.2 29.9-29.6 29.9z" p-id="3856"></path><path d="M297.6 310.4l0.1-0.2 14.9 14.9c2.5 1.7 5.5 2.4 8.5 2.1 122.8 39.3 254.9 38.3 377.3-2.8 2.1-1.2 4.2-2.3 6.4-3.5 27-22.3 48.2-50.9 61.7-83.2 6.3-14.9 6.3-21.3 12.8-36.2 1-7.5 1.1-13.8 1.4-20.4 0.3-0.7 0.4-1.2 0.7-1.9 6.3-46.9 0-74.5-27.6-95.8-22.9-14.8-49.4-22.9-76.7-23.4-17.9-1.1-35.8 3.4-51.1 12.8h-2c-0.6 0-1.1-0.2-1.5-0.6-0.4-0.4-0.6-0.9-0.6-1.5-29.3-26.3-67.3-40.7-106.6-40.6-38.7-0.5-76.1 14-104.5 40.4-6.3 0-6.3 2.1-8.5 2.1h-2.2c-15.6-6.2-32.3-9.1-49.1-8.5-8.6-0.4-17.2 0.3-25.6 2.1-24.1 1.9-46.4 13.4-62 31.8-14.3 16.9-21.5 38.4-21.1 60.4-2.1 9.2-3.3 18.7-2.4 28.3 6 46.4 26.1 89.5 57.7 123.7z" p-id="3857"></path></svg>',link:"img | /images/payment.jpg"},Wechat:{svg:'<svg t="1718087712961" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1061" width="200" height="200"><path d="M26.54814827 512a485.45185173 485.45185173 0 1 1 970.90370346 0A485.45185173 485.45185173 0 0 1 26.54814827 512z m596.86305173-90.41540693c7.16041493 0 14.19946667 0.60681493 21.3598816 1.2136288C625.71709653 334.62802987 530.2651264 269.2740736 421.46322987 269.2740736 299.61481493 269.2740736 199.85445973 351.13339307 199.85445973 455.26281493c0 60.07466667 33.07140693 109.46939307 88.53428054 147.75940694l-22.14874027 65.839408 77.49025173-38.53274134c27.6707552 5.33997013 50.00154027 10.92266667 77.49025174 10.92266667 6.85700693 0 13.77469653-0.2427264 20.63170346-0.97090347a156.19413333 156.19413333 0 0 1-6.79632533-45.6931552c0-95.51265173 83.01226667-173.00290347 188.3553184-173.00290346h-0.0606816z m-119.17842987-59.3464896c16.6267264 0 27.6707552 10.92266667 27.67075627 27.30666666s-11.04402987 27.30666667-27.67075627 27.30666667c-16.74808853 0-33.37481493-10.92266667-33.37481493-27.30666667 0.30340693-16.384 16.93013333-27.30666667 33.37481493-27.30666666z m-155.04118506 54.73469653c-16.68740693 0-33.37481493-10.92266667-33.37481494-27.30666667 0-16.4446816 16.68740693-27.30666667 33.37481494-27.30666666 16.6267264 0 27.6707552 10.86198507 27.6707552 27.30666666 0 16.2019552-10.92266667 27.30666667-27.6707552 27.30666667z m476.28894826 175.0660736c0-87.38133333-88.5342816-158.56071147-188.11259306-158.5607104-105.40373333 0-188.3553184 71.24005973-188.3553184 158.5607104 0 87.68474027 82.95158507 158.6820736 188.3553184 158.68207467 22.08805973 0 44.4188448-5.58269653 66.50690453-10.92266667l60.86352533 32.9500448-16.68740693-54.73469653c44.2974816-32.9500448 77.42957013-76.7620736 77.42957013-125.97475627z m-249.0974816-27.30666667c-11.10471147 0-22.08805973-10.92266667-22.08805866-21.84533333 0-10.86198507 10.98334827-21.72397013 22.08805866-21.72397013 16.68740693 0 27.6707552 10.92266667 27.6707552 21.78465173 0 10.92266667-11.10471147 21.78465173-27.6707552 21.78465173z m121.84841494 0c-11.04402987 0-22.02737813-10.92266667-22.02737814-21.84533333 0-10.86198507 10.98334827-21.72397013 22.08805974-21.72397013 16.5660448 0 27.6707552 10.92266667 27.6707552 21.78465173 0 10.92266667-11.3474368 21.78465173-27.6707552 21.78465173h-0.0606816z" fill="#333333" p-id="1062"></path></svg>',link:"img | /images/wx_qrcode.jpg"}}},version:"4.1.3"},KEEP.language_ago={second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days ago",week:"%s weeks ago",month:"%s months ago",year:"%s years ago"},KEEP.language_code_block={copy:"Copy code",copied:"Copied",fold:"Fold code block",folded:"Folded"},KEEP.language_copy_copyright={copy:"Copy copyright info",copied:"Copied",title:"Original post title",author:"Original post author",link:"Original post link"}</script><meta name=generator content="Hexo 7.3.0"></head><body><div class=progress-bar-container><span class=scroll-progress-bar></span></div><main class="page-container border-box"><div class="page-main-content border-box"><div class=page-main-content-top><header class=header-wrapper><div class="border-box header-content"><div class="left border-box"><a class="logo-image border-box" href=/ ><img src=/images/logo.svg alt=logo> </a><a class="site-name border-box" href=/ >cmdragon&#39;s Blog</a></div><div class="right border-box"><div class=pc><ul class=menu-list><li class=menu-item><a class="" href=/ >首页</a></li><li class=menu-item><a class="" href=/archives>归档</a></li><li class=menu-item><a class="" target=_blank rel=noopener href=https://tools.cmdragon.cn>工具箱</a></li><li class=menu-item><a class="" href=/links>友链</a></li><li class="menu-item search search-popup-trigger"><i class="fas search fa-search"></i></li></ul></div><div class=mobile><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class=menu-bar-middle></div></div></div></div></div><div class=header-drawer><ul class=drawer-menu-list><li class="drawer-menu-item flex-center"><a class="" href=/ >首页</a></li><li class="drawer-menu-item flex-center"><a class="" href=/archives>归档</a></li><li class="drawer-menu-item flex-center"><a class="" target=_blank rel=noopener href=https://tools.cmdragon.cn>工具箱</a></li><li class="drawer-menu-item flex-center"><a class="" href=/links>友链</a></li></ul></div><div class=window-mask></div></header></div><div class="page-main-content-middle border-box"><div class="main-content border-box"><div class=fade-in-down-animation><div class="post-page-container border-box"><div class="post-content-container border-box"><div class="post-content-bottom border-box"><h1 class=post-title>深入理解Python协程：从基础到实战</h1><div class="post-header border-box"><div class="avatar-box border-box"><img src=/images/avatar.jpg alt=avatar></div><div class=info-box><div class="author border-box"><span class=name>cmdragon</span> <span class=author-badge>大乘</span></div><div class="meta-info border-box"><div class="post-meta-info-container border-box post"><div class="post-meta-info border-box"><span class="meta-info-item post-create-date"><i class="icon fa-solid fa-calendar-plus"></i>&nbsp; <span class=datetime>2024-04-27 16:48:43</span> </span><span class="meta-info-item post-update-date"><i class="icon fa-solid fa-file-pen"></i>&nbsp; <span class=datetime data-updated="Sat Apr 27 2024 08:48:43 GMT+0000">2024-04-27 16:48:43</span> </span><span class="meta-info-item post-category border-box"><i class="icon fas fa-folder"></i>&nbsp;<ul class=post-category-ul><li class=category-item><a href=/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/ >后端开发</a></li></ul></span><span class="post-tag meta-info-item border-box"><ul class=post-tag-ul><li class=tag-item><span class=tag-separator><i class="icon fas fa-hashtag"></i></span><a href=/tags/%E5%8D%8F%E7%A8%8B/ >协程</a></li><li class=tag-item><span class=tag-separator><i class="icon fas fa-hashtag"></i></span><a href=/tags/%E5%BC%82%E6%AD%A5IO/ >异步IO</a></li><li class=tag-item><span class=tag-separator><i class="icon fas fa-hashtag"></i></span><a href=/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ >并发编程</a></li><li class=tag-item><span class=tag-separator><i class="icon fas fa-hashtag"></i></span><a href=/tags/Python/ >Python</a></li><li class=tag-item><span class=tag-separator><i class="icon fas fa-hashtag"></i></span><a href=/tags/aiohttp/ >aiohttp</a></li><li class=tag-item><span class=tag-separator><i class="icon fas fa-hashtag"></i></span><a href=/tags/asyncio/ >asyncio</a></li><li class=tag-item><span class=tag-separator><i class="icon fas fa-hashtag"></i></span><a href=/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/ >网络爬虫</a></li></ul></span><span class="meta-info-item post-wordcount"><i class="icon fas fa-file-word"></i>&nbsp;<span>7.8k 字</span> </span><span class="meta-info-item post-min2read"><i class="icon fas fa-clock"></i>&nbsp;<span>30 分钟</span></span></div></div></div></div></div><div class="post-content keep-markdown-body"><img lazyload alt=image data-src="https://static.amd794.com/blog/images/2024_04_27 17_03_18.png@blog" title="2024_04_27 17_03_18.png" alt="2024_04_27 17_03_18.png"> <img lazyload alt=image data-src="https://static.amd794.com/blog/images/2024_04_27 17_05_32.png@blog" title="2024_04_27 17_05_32.png" alt="2024_04_27 17_05_32.png"><h2 id=第1章：协程基础><a href=#第1章：协程基础 class=headerlink title=第1章：协程基础></a><strong>第1章：协程基础</strong></h2><h3 id=1-1-协程概念介绍><a href=#1-1-协程概念介绍 class=headerlink title="1.1 协程概念介绍"></a><strong>1.1 协程概念介绍</strong></h3><p>协程（Coroutines）是一种特殊的软件构造，它允许程序在执行过程中暂停并恢复执行，而不会丢失当前的执行上下文。与线程和进程不同，协程在单个线程中运行，通过调度机制实现并发，降低了上下文切换的开销，提高了程序的执行效率。协程通常用于处理I&#x2F;O密集型任务，如网络请求、文件读写等。</p><h3 id=1-2-生成器与yield的原理><a href=#1-2-生成器与yield的原理 class=headerlink title="1.2 生成器与yield的原理"></a><strong>1.2 生成器与yield的原理</strong></h3><p>生成器（Generators）是Python中实现协程的一种方式，它通过内置的<code>yield</code>关键字来暂停和恢复执行。当函数遇到<code>yield</code><br>时，会暂停执行并返回一个值，下次调用时会从上次暂停的地方继续执行。<code>yield</code><br>实际上是一个特殊的return语句，它会保存当前的状态（包括局部变量和执行上下文），当再次调用时，这些状态会被恢复。</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>def</span> <span class="title function_">coroutine_example</span>():</span><br><span class=line>    value = <span class=keyword>yield</span> <span class=number>0</span></span><br><span class=line>    <span class=built_in>print</span>(<span class=string>f&#x27;Received value: <span class=subst>&#123;value&#125;</span>&#x27;</span>)</span><br><span class=line>    value = <span class=keyword>yield</span> <span class=number>1</span></span><br><span class=line>    <span class=built_in>print</span>(<span class=string>f&#x27;Received value: <span class=subst>&#123;value&#125;</span>&#x27;</span>)</span><br><span class=line></span><br><span class=line></span><br><span class=line>c = coroutine_example()</span><br><span class=line><span class=built_in>next</span>(c)  <span class=comment># 输出 &#x27;Received value: 0&#x27;</span></span><br><span class=line><span class=built_in>print</span>(c.send(<span class=number>2</span>))  <span class=comment># 输出 &#x27;Received value: 1&#x27;</span></span><br></pre></td></tr></table></figure><h3 id=1-3-协程与多线程-多进程的区别><a href=#1-3-协程与多线程-多进程的区别 class=headerlink title="1.3 协程与多线程&#x2F;多进程的区别"></a><strong>1.3 协程与多线程&#x2F;多进程的区别</strong></h3><ul><li><strong>多线程</strong>：线程是操作系统层面的并行执行单位，线程间通信需要锁等同步机制，上下文切换开销大，适合CPU密集型任务。</li><li><strong>多进程</strong>：进程是独立的执行环境，拥有自己的内存空间，适合I&#x2F;O密集型任务，但创建和销毁进程开销大。</li><li><strong>协程</strong>：协程在单线程中通过控制流切换实现并发，没有线程切换开销，但资源占用相对较少，适合I&#x2F;O等待任务。</li></ul><h3 id=1-4-协程的生命周期与状态转换><a href=#1-4-协程的生命周期与状态转换 class=headerlink title="1.4 协程的生命周期与状态转换"></a><strong>1.4 协程的生命周期与状态转换</strong></h3><ul><li><strong>创建</strong>：函数定义为生成器，使用<code>yield</code>关键字。</li><li><strong>启动</strong>：通过调用生成器实例的<code>next()</code>或<code>send()</code>方法开始执行，直到遇到<code>yield</code>。</li><li><strong>暂停</strong>：遇到<code>yield</code>时，函数暂停，保存当前状态。</li><li><strong>恢复</strong>：通过<code>send()</code>方法传入值，函数从上次暂停的地方继续执行。</li><li><strong>结束</strong>：当没有更多<code>yield</code>可执行，或遇到<code>return</code>语句时，协程结束。</li></ul><h2 id=第2章：协程实践基础><a href=#第2章：协程实践基础 class=headerlink title=第2章：协程实践基础></a><strong>第2章：协程实践基础</strong></h2><h3 id=2-1-使用asyncio库><a href=#2-1-使用asyncio库 class=headerlink title="2.1 使用asyncio库"></a><strong>2.1 使用asyncio库</strong></h3><p><code>asyncio</code>是 Python 中用于编写异步代码的标准库，它提供了一组工具和API来管理和调度协程。通过<code>asyncio</code>，可以轻松创建、执行和管理异步任务。</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>import</span> asyncio</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">async_function</span>():</span><br><span class=line>    <span class=keyword>await</span> asyncio.sleep(<span class=number>1</span>)</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>&quot;Async function executed&quot;</span>)</span><br><span class=line></span><br><span class=line></span><br><span class=line>asyncio.run(async_function())</span><br></pre></td></tr></table></figure><h3 id=2-2-异步函数与async-await><a href=#2-2-异步函数与async-await class=headerlink title="2.2 异步函数与async&#x2F;await"></a><strong>2.2 异步函数与async&#x2F;await</strong></h3><p><code>async</code>关键字用于定义异步函数，<code>await</code>关键字用于暂停异步函数的执行，等待另一个异步任务完成。</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>import</span> asyncio</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">async_function</span>():</span><br><span class=line>    <span class=keyword>await</span> asyncio.sleep(<span class=number>1</span>)</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>&quot;Async function executed&quot;</span>)</span><br><span class=line></span><br><span class=line></span><br><span class=line>asyncio.run(async_function())</span><br></pre></td></tr></table></figure><h3 id=2-3-协程的调度与调度器><a href=#2-3-协程的调度与调度器 class=headerlink title="2.3 协程的调度与调度器"></a><strong>2.3 协程的调度与调度器</strong></h3><p><code>asyncio</code>提供了事件循环（Event Loop）来调度协程的执行。事件循环负责管理和调度所有的协程任务，确保它们按照正确的顺序执行。</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>import</span> asyncio</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">task</span>():</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>&quot;Task executed&quot;</span>)</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">main</span>():</span><br><span class=line>    <span class=keyword>await</span> asyncio.gather(task(), task())</span><br><span class=line></span><br><span class=line></span><br><span class=line>asyncio.run(main())</span><br></pre></td></tr></table></figure><h3 id=2-4-示例：网络请求的异步处理><a href=#2-4-示例：网络请求的异步处理 class=headerlink title="2.4 示例：网络请求的异步处理"></a><strong>2.4 示例：网络请求的异步处理</strong></h3><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>import</span> asyncio</span><br><span class=line><span class=keyword>import</span> aiohttp</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">fetch</span>(<span class=params>url</span>):</span><br><span class=line>    <span class=keyword>async</span> <span class=keyword>with</span> aiohttp.ClientSession() <span class=keyword>as</span> session:</span><br><span class=line>        <span class=keyword>async</span> <span class=keyword>with</span> session.get(url) <span class=keyword>as</span> response:</span><br><span class=line>            <span class=keyword>return</span> <span class=keyword>await</span> response.text()</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">main</span>():</span><br><span class=line>    urls = [<span class=string>&#x27;http://example.com&#x27;</span>, <span class=string>&#x27;http://example.org&#x27;</span>]</span><br><span class=line>    tasks = [fetch(url) <span class=keyword>for</span> url <span class=keyword>in</span> urls]</span><br><span class=line>    responses = <span class=keyword>await</span> asyncio.gather(*tasks)</span><br><span class=line>    <span class=keyword>for</span> response <span class=keyword>in</span> responses:</span><br><span class=line>        <span class=built_in>print</span>(response)</span><br><span class=line></span><br><span class=line></span><br><span class=line>asyncio.run(main())</span><br></pre></td></tr></table></figure><p>这个例子演示了如何使用<code>asyncio</code>和<code>aiohttp</code>库进行异步的网络请求处理。<code>fetch()</code>函数负责发送 HTTP<br>请求并返回响应内容，<code>main()</code>函数创建了多个任务，并使用<code>asyncio.gather()</code>并行执行这些任务，最后输出每个请求的响应内容。</p><h2 id=第3章：协程的高级应用><a href=#第3章：协程的高级应用 class=headerlink title=第3章：协程的高级应用></a>第3章：<strong>协程的高级应用</strong></h2><h3 id=异步并发编程的基本概念><a href=#异步并发编程的基本概念 class=headerlink title=异步并发编程的基本概念></a>异步并发编程的基本概念</h3><h4 id=1-异步编程的概念和优势><a href=#1-异步编程的概念和优势 class=headerlink title="1. 异步编程的概念和优势"></a>1. 异步编程的概念和优势</h4><p>异步编程是一种编程范式，允许程序在等待某些操作完成的同时继续执行其他任务，而不会被阻塞。相比于传统的同步编程方式，异步编程具有以下优势：</p><ul><li><strong>提高程序性能</strong>：异步编程可以充分利用计算资源，减少等待时间，从而提高程序的响应速度和并发处理能力。</li><li><strong>提升用户体验</strong>：在I&#x2F;O密集型任务中，异步编程可以使程序在等待I&#x2F;O操作完成时继续执行其他任务，提升用户体验。</li><li><strong>简化编程模型</strong>：通过异步编程，可以避免复杂的回调嵌套，提高代码的可读性和维护性。</li></ul><h4 id=2-协程是如何实现异步编程的关键技术><a href=#2-协程是如何实现异步编程的关键技术 class=headerlink title="2. 协程是如何实现异步编程的关键技术"></a>2. 协程是如何实现异步编程的关键技术</h4><p>协程是一种轻量级的线程，可以在执行过程中暂停并恢复。在Python中，协程通过<code>async</code>和<code>await</code><br>关键字实现，是异步编程的关键技术之一。协程的实现原理包括以下几个关键点：</p><ul><li><strong>异步函数定义</strong>：使用<code>async def</code>定义的函数可以在函数内部使用<code>await</code>关键字来挂起函数的执行，等待异步操作完成。</li><li><strong>事件循环</strong>：异步编程通常需要一个事件循环来调度协程的执行，Python中的<code>asyncio</code>库提供了事件循环的支持。</li><li><strong>协程调度</strong>：事件循环会根据协程的状态和优先级调度协程的执行，使得程序能够在不同的协程之间切换执行，实现异步编程的效果。</li></ul><h3 id=3-异步事件循环与任务池><a href=#3-异步事件循环与任务池 class=headerlink title="3. 异步事件循环与任务池"></a>3. 异步事件循环与任务池</h3><h4 id=1-异步事件循环的原理和作用><a href=#1-异步事件循环的原理和作用 class=headerlink title="1. 异步事件循环的原理和作用"></a>1. 异步事件循环的原理和作用</h4><p>异步事件循环是异步编程中的核心概念，负责协调和调度异步任务的执行。其原理包括以下几个关键点：</p><ul><li><strong>事件循环</strong>：异步事件循环通过不断循环检查事件队列中的任务，根据任务的状态和优先级来调度任务的执行。</li><li><strong>任务调度</strong>：事件循环会根据任务的状态（挂起、就绪、运行）和优先级来决定任务的执行顺序，以实现异步编程的效果。</li><li><strong>挂起和恢复</strong>：事件循环能够在任务需要等待I&#x2F;O操作完成时挂起任务，等待事件发生后再恢复任务的执行。</li></ul><p>异步事件循环的作用在于提供一个统一的调度器，使得异步任务能够在不同的协程之间切换执行，实现非阻塞的并发处理。</p><h4 id=2-任务池在异步编程中的重要性><a href=#2-任务池在异步编程中的重要性 class=headerlink title="2. 任务池在异步编程中的重要性"></a>2. 任务池在异步编程中的重要性</h4><p>任务池是一种管理和调度异步任务的机制，用于管理大量的异步任务并控制其并发执行。任务池在异步编程中具有以下重要性：</p><ul><li><strong>控制并发度</strong>：任务池可以限制同时执行的任务数量，避免系统资源被过度占用，提高程序的稳定性和性能。</li><li><strong>任务调度</strong>：任务池可以根据任务的优先级和状态来调度任务的执行顺序，确保任务按照预期的顺序执行。</li><li><strong>异常处理</strong>：任务池可以捕获和处理任务执行过程中的异常，避免异常导致整个程序崩溃。</li></ul><p>任务池在异步编程中扮演着重要的角色，能够有效管理和调度大量的异步任务，提高程序的效率和可靠性。</p><h4 id=3-示例：使用asyncio库创建和管理任务集合><a href=#3-示例：使用asyncio库创建和管理任务集合 class=headerlink title="3. 示例：使用asyncio库创建和管理任务集合"></a>3. 示例：使用asyncio库创建和管理任务集合</h4><p>下面是一个简单的示例，演示如何使用<code>asyncio</code>库创建和管理任务集合：</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>import</span> asyncio</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">task</span>(<span class=params>num</span>):</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>f&quot;Task <span class=subst>&#123;num&#125;</span> started&quot;</span>)</span><br><span class=line>    <span class=keyword>await</span> asyncio.sleep(<span class=number>1</span>)</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>f&quot;Task <span class=subst>&#123;num&#125;</span> completed&quot;</span>)</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">main</span>():</span><br><span class=line>    tasks = [task(i) <span class=keyword>for</span> i <span class=keyword>in</span> <span class=built_in>range</span>(<span class=number>3</span>)]  <span class=comment># 创建多个任务</span></span><br><span class=line>    <span class=keyword>await</span> asyncio.gather(*tasks)  <span class=comment># 等待所有任务完成</span></span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>if</span> __name__ == <span class=string>&quot;__main__&quot;</span>:</span><br><span class=line>    asyncio.run(main())  <span class=comment># 运行主函数</span></span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个异步任务<code>task</code>，然后在<code>main</code>函数中创建了多个任务，并使用<code>asyncio.gather</code><br>来等待所有任务完成。最后通过<code>asyncio.run</code>来运行主函数。这样就实现了使用<code>asyncio</code>库创建和管理任务集合的功能。</p><h3 id=协程池与资源管理><a href=#协程池与资源管理 class=headerlink title=协程池与资源管理></a>协程池与资源管理</h3><h4 id=1-协程池在并发编程中的作用和优化策略><a href=#1-协程池在并发编程中的作用和优化策略 class=headerlink title="1. 协程池在并发编程中的作用和优化策略"></a>1. 协程池在并发编程中的作用和优化策略</h4><p>协程池是一种用于管理和调度协程执行的机制，可以控制并发度、减少资源占用和提高程序性能。协程池在并发编程中的作用和优化策略包括：</p><ul><li><strong>控制并发度</strong>：协程池可以限制同时执行的协程数量，避免资源过度占用，提高程序的稳定性。</li><li><strong>复用资源</strong>：协程池可以复用已经创建的协程，减少频繁创建和销毁协程的开销，提高程序的效率。</li><li><strong>调度协程</strong>：协程池可以根据任务的状态和优先级来调度协程的执行顺序，确保任务按照预期的顺序执行。</li><li><strong>优化性能</strong>：通过合理配置协程池的大小和参数，可以优化程序的性能，提高并发处理能力。</li></ul><p>优化策略包括合理设置协程池的大小、避免阻塞操作、及时处理协程的返回值等，以提高程序的效率和性能。</p><h4 id=2-资源管理的重要性和如何避免资源泄露><a href=#2-资源管理的重要性和如何避免资源泄露 class=headerlink title="2. 资源管理的重要性和如何避免资源泄露"></a>2. 资源管理的重要性和如何避免资源泄露</h4><p>资源管理在并发编程中非常重要，可以避免资源泄露和提高程序的稳定性。避免资源泄露的方法包括：</p><ul><li><strong>使用上下文管理器</strong>：对于文件、网络连接等资源，使用<code>with</code>语句可以确保资源在使用完毕后及时释放。</li><li><strong>手动释放资源</strong>：对于一些需要手动释放的资源，如内存、数据库连接等，及时调用相应的释放资源的方法。</li><li><strong>避免循环引用</strong>：在异步编程中，避免循环引用导致资源无法释放，可以使用弱引用等方式来处理。</li></ul><p>良好的资源管理能够避免资源泄露和提高程序的稳定性，确保程序的正常运行。</p><h4 id=3-如何有效管理协程的取消和异常处理><a href=#3-如何有效管理协程的取消和异常处理 class=headerlink title="3. 如何有效管理协程的取消和异常处理"></a>3. 如何有效管理协程的取消和异常处理</h4><p>在异步编程中，管理协程的取消和异常处理是非常重要的，可以提高程序的健壮性。有效管理协程的取消和异常处理包括：</p><ul><li><strong>取消协程</strong>：使用<code>asyncio.Task.cancel()</code>方法可以取消正在执行的协程，避免不必要的资源消耗。</li><li><strong>异常处理</strong>：在协程中使用<code>try-except</code>语句捕获异常，并根据实际情况处理异常，避免程序崩溃。</li><li><strong>统一异常处理</strong>：可以使用<code>asyncio.create_task()</code>创建任务，并在任务中统一处理异常，以确保程序的稳定性。</li></ul><p>通过合理取消协程和处理异常，可以有效管理协程的执行过程，提高程序的可靠性和健壮性。</p><h3 id=示例：使用协程实现高效的Web服务器><a href=#示例：使用协程实现高效的Web服务器 class=headerlink title=示例：使用协程实现高效的Web服务器></a>示例：使用协程实现高效的Web服务器</h3><h4 id=1-异步编程提高性能><a href=#1-异步编程提高性能 class=headerlink title="1. 异步编程提高性能"></a>1. 异步编程提高性能</h4><p>异步编程在Web服务器中的应用可以显著提高性能，因为它允许服务器在等待客户端响应时处理其他请求，而不是阻塞。这种方式提高了服务器的并发处理能力，使得在高负载情况下也能保持良好的响应速度。</p><h4 id=2-使用aiohttp构建异步Web服务器><a href=#2-使用aiohttp构建异步Web服务器 class=headerlink title="2. 使用aiohttp构建异步Web服务器"></a>2. 使用aiohttp构建异步Web服务器</h4><p>aiohttp是一个用于构建高性能HTTP&#x2F;HTTPS服务器和客户端的Python库，它非常适合异步IO操作。下面是一个简单的aiohttp异步Web服务器示例：</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>import</span> asyncio</span><br><span class=line><span class=keyword>from</span> aiohttp <span class=keyword>import</span> web</span><br><span class=line></span><br><span class=line>runner = <span class=literal>None</span>  <span class=comment># 定义全局变量 runner</span></span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">handle_request</span>(<span class=params>request</span>):</span><br><span class=line>    name = request.match_info.get(<span class=string>&#x27;name&#x27;</span>, <span class=string>&#x27;World&#x27;</span>)</span><br><span class=line>    text = <span class=string>f&#x27;Hello, <span class=subst>&#123;name&#125;</span>!&#x27;</span></span><br><span class=line>    <span class=keyword>return</span> web.Response(text=text)</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">run_app</span>(<span class=params>app</span>):</span><br><span class=line>    <span class=keyword>global</span> runner  <span class=comment># 声明使用全局变量 runner</span></span><br><span class=line>    runner = web.AppRunner(app)</span><br><span class=line>    <span class=keyword>await</span> runner.setup()</span><br><span class=line>    site = web.TCPSite(runner, <span class=string>&#x27;127.0.0.1&#x27;</span>, <span class=number>8080</span>)</span><br><span class=line>    <span class=keyword>await</span> site.start()</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">main</span>():</span><br><span class=line>    app = web.Application()</span><br><span class=line>    app.router.add_get(<span class=string>&#x27;/&#123;name&#125;&#x27;</span>, handle_request)</span><br><span class=line></span><br><span class=line>    <span class=keyword>try</span>:</span><br><span class=line>        <span class=built_in>print</span>(<span class=string>&#x27;Server started at http://127.0.0.1:8080&#x27;</span>)</span><br><span class=line>        <span class=keyword>await</span> run_app(app)</span><br><span class=line>    <span class=keyword>except</span> KeyboardInterrupt:</span><br><span class=line>        <span class=keyword>pass</span></span><br><span class=line>    <span class=keyword>finally</span>:</span><br><span class=line>        <span class=keyword>if</span> runner <span class=keyword>is</span> <span class=keyword>not</span> <span class=literal>None</span>:  <span class=comment># 检查 runner 是否已初始化</span></span><br><span class=line>            <span class=keyword>await</span> runner.cleanup()  <span class=comment># 使用 runner.cleanup() 替代 runner.shutdown()</span></span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>if</span> __name__ == <span class=string>&#x27;__main__&#x27;</span>:</span><br><span class=line>    asyncio.run(main())  <span class=comment># 使用 asyncio.run() 简化事件循环管理</span></span><br><span class=line></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>handle_request</code>函数是协程，它接收一个请求，处理并返回响应。<code>app()</code>函数创建了一个应用实例，添加路由，并启动一个事件循环来监听请求。</p><h4 id=3-异步请求处理、事件循环和任务池的协作><a href=#3-异步请求处理、事件循环和任务池的协作 class=headerlink title="3. 异步请求处理、事件循环和任务池的协作"></a>3. 异步请求处理、事件循环和任务池的协作</h4><ul><li><strong>异步请求处理</strong>：aiohttp的<code>web.Request</code>对象和<code>web.View</code>接口都是异步的，通过<code>async def</code>定义的函数处理请求，可以在处理过程中执行其他协程，提高效率。</li><li><strong>事件循环</strong>：<code>asyncio.get_event_loop()</code>获取事件循环，它负责调度协程的执行，当有新的请求到达时，它会将请求添加到任务队列中，等待调度。</li><li><strong>任务池</strong>：虽然aiohttp没有直接提供任务池，但事件循环本质上就是一个任务池，它可以同时执行多个协程，直到事件循环结束或有新的任务加入。</li></ul><p>通过这种方式，aiohttp可以实现高效的Web服务器，提高并发处理能力，同时避免了阻塞，使得服务器在高负载下仍能保持良好的性能。</p><h2 id=第4章：协程与异步IO><a href=#第4章：协程与异步IO class=headerlink title=第4章：协程与异步IO></a>第4章：协程与异步IO</h2><h4 id=4-1-文件操作与Socket编程的异步处理><a href=#4-1-文件操作与Socket编程的异步处理 class=headerlink title="4.1 文件操作与Socket编程的异步处理"></a>4.1 文件操作与Socket编程的异步处理</h4><p>在异步IO中，文件操作和Socket编程是常见的任务，可以通过协程实现异步处理以提高效率。</p><h5 id=文件操作的异步处理：><a href=#文件操作的异步处理： class=headerlink title=文件操作的异步处理：></a>文件操作的异步处理：</h5><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>import</span> asyncio</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">read_file_async</span>(<span class=params>file_path</span>):</span><br><span class=line>    <span class=keyword>async</span> <span class=keyword>with</span> <span class=built_in>open</span>(file_path, <span class=string>&#x27;r&#x27;</span>) <span class=keyword>as</span> file:</span><br><span class=line>        data = <span class=keyword>await</span> file.read()</span><br><span class=line>        <span class=keyword>return</span> data</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">write_file_async</span>(<span class=params>file_path, data</span>):</span><br><span class=line>    <span class=keyword>async</span> <span class=keyword>with</span> <span class=built_in>open</span>(file_path, <span class=string>&#x27;w&#x27;</span>) <span class=keyword>as</span> file:</span><br><span class=line>        <span class=keyword>await</span> file.write(data)</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=comment># 使用示例</span></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">main</span>():</span><br><span class=line>    data = <span class=keyword>await</span> read_file_async(<span class=string>&#x27;example.txt&#x27;</span>)</span><br><span class=line>    <span class=keyword>await</span> write_file_async(<span class=string>&#x27;example_copy.txt&#x27;</span>, data)</span><br><span class=line></span><br><span class=line></span><br><span class=line>asyncio.run(main())</span><br></pre></td></tr></table></figure><h5 id=Socket编程的异步处理：><a href=#Socket编程的异步处理： class=headerlink title=Socket编程的异步处理：></a>Socket编程的异步处理：</h5><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>import</span> asyncio</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">handle_client</span>(<span class=params>reader, writer</span>):</span><br><span class=line>    data = <span class=keyword>await</span> reader.read(<span class=number>100</span>)</span><br><span class=line>    message = data.decode()</span><br><span class=line>    addr = writer.get_extra_info(<span class=string>&#x27;peername&#x27;</span>)</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>f&quot;Received <span class=subst>&#123;message&#125;</span> from <span class=subst>&#123;addr&#125;</span>&quot;</span>)</span><br><span class=line></span><br><span class=line>    <span class=built_in>print</span>(<span class=string>f&quot;Send: <span class=subst>&#123;message&#125;</span>&quot;</span>)</span><br><span class=line>    writer.write(data)</span><br><span class=line>    <span class=keyword>await</span> writer.drain()</span><br><span class=line></span><br><span class=line>    <span class=built_in>print</span>(<span class=string>&quot;Closing the connection&quot;</span>)</span><br><span class=line>    writer.close()</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">main</span>():</span><br><span class=line>    server = <span class=keyword>await</span> asyncio.start_server(</span><br><span class=line>        handle_client, <span class=string>&#x27;127.0.0.1&#x27;</span>, <span class=number>8888</span>)</span><br><span class=line></span><br><span class=line>    addr = server.sockets[<span class=number>0</span>].getsockname()</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>f&#x27;Serving on <span class=subst>&#123;addr&#125;</span>&#x27;</span>)</span><br><span class=line></span><br><span class=line>    <span class=keyword>async</span> <span class=keyword>with</span> server:</span><br><span class=line>        <span class=keyword>await</span> server.serve_forever()</span><br><span class=line></span><br><span class=line></span><br><span class=line>asyncio.run(main())</span><br></pre></td></tr></table></figure><h4 id=4-2-数据库操作的异步编程><a href=#4-2-数据库操作的异步编程 class=headerlink title="4.2 数据库操作的异步编程"></a>4.2 数据库操作的异步编程</h4><p>数据库操作通常涉及磁盘IO和网络IO，因此异步编程在此领域尤为重要。常见的数据库操作库如asyncpg、aiomysql等都提供了异步接口。</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>import</span> asyncio</span><br><span class=line><span class=keyword>import</span> asyncpg</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">fetch_data</span>():</span><br><span class=line>    conn = <span class=keyword>await</span> asyncpg.connect(user=<span class=string>&#x27;user&#x27;</span>, password=<span class=string>&#x27;password&#x27;</span>,</span><br><span class=line>                                 database=<span class=string>&#x27;database&#x27;</span>, host=<span class=string>&#x27;127.0.0.1&#x27;</span>)</span><br><span class=line>    values = <span class=keyword>await</span> conn.fetch(<span class=string>&#x27;&#x27;&#x27;SELECT * FROM table&#x27;&#x27;&#x27;</span>)</span><br><span class=line>    <span class=keyword>await</span> conn.close()</span><br><span class=line>    <span class=keyword>return</span> values</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">main</span>():</span><br><span class=line>    data = <span class=keyword>await</span> fetch_data()</span><br><span class=line>    <span class=built_in>print</span>(data)</span><br><span class=line></span><br><span class=line></span><br><span class=line>asyncio.run(main())</span><br></pre></td></tr></table></figure><h4 id=4-3-示例：异步数据库操作与文件读写><a href=#4-3-示例：异步数据库操作与文件读写 class=headerlink title="4.3 示例：异步数据库操作与文件读写"></a>4.3 示例：异步数据库操作与文件读写</h4><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>import</span> asyncio</span><br><span class=line><span class=keyword>import</span> asyncpg</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">fetch_data_and_write_to_file</span>():</span><br><span class=line>    conn = <span class=keyword>await</span> asyncpg.connect(user=<span class=string>&#x27;user&#x27;</span>, password=<span class=string>&#x27;password&#x27;</span>,</span><br><span class=line>                                 database=<span class=string>&#x27;database&#x27;</span>, host=<span class=string>&#x27;127.0.0.1&#x27;</span>)</span><br><span class=line>    values = <span class=keyword>await</span> conn.fetch(<span class=string>&#x27;&#x27;&#x27;SELECT * FROM table&#x27;&#x27;&#x27;</span>)</span><br><span class=line>    <span class=keyword>await</span> conn.close()</span><br><span class=line></span><br><span class=line>    <span class=keyword>async</span> <span class=keyword>with</span> <span class=built_in>open</span>(<span class=string>&#x27;database_data.txt&#x27;</span>, <span class=string>&#x27;w&#x27;</span>) <span class=keyword>as</span> file:</span><br><span class=line>        <span class=keyword>for</span> row <span class=keyword>in</span> values:</span><br><span class=line>            file.write(<span class=built_in>str</span>(row) + <span class=string>&#x27;\n&#x27;</span>)</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">main</span>():</span><br><span class=line>    <span class=keyword>await</span> fetch_data_and_write_to_file()</span><br><span class=line></span><br><span class=line></span><br><span class=line>asyncio.run(main())</span><br></pre></td></tr></table></figure><p>在这个示例中，我们连接到数据库，从表中检索数据，然后将数据写入到文件中。所有这些操作都是异步的，通过协程实现了非阻塞的数据库操作和文件IO。</p><h2 id=第5章：协程与并发控制><a href=#第5章：协程与并发控制 class=headerlink title=第5章：协程与并发控制></a>第5章：协程与并发控制</h2><h4 id=5-1-锁与同步原语在协程中的应用><a href=#5-1-锁与同步原语在协程中的应用 class=headerlink title="5.1 锁与同步原语在协程中的应用"></a>5.1 锁与同步原语在协程中的应用</h4><p>在协程中，为了避免并发访问共享资源时出现数据竞争的情况，可以使用锁（Lock）等同步原语来实现线程间的互斥。</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>import</span> asyncio</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">task</span>(<span class=params>lock</span>):</span><br><span class=line>    <span class=keyword>async</span> <span class=keyword>with</span> lock:</span><br><span class=line>        <span class=comment># 访问共享资源的代码</span></span><br><span class=line>        <span class=built_in>print</span>(<span class=string>&quot;Accessing shared resource&quot;</span>)</span><br><span class=line>        <span class=keyword>await</span> asyncio.sleep(<span class=number>1</span>)</span><br><span class=line>        <span class=built_in>print</span>(<span class=string>&quot;Finished accessing shared resource&quot;</span>)</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">main</span>():</span><br><span class=line>    lock = asyncio.Lock()</span><br><span class=line>    tasks = [task(lock) <span class=keyword>for</span> _ <span class=keyword>in</span> <span class=built_in>range</span>(<span class=number>5</span>)]</span><br><span class=line>    <span class=keyword>await</span> asyncio.gather(*tasks)</span><br><span class=line></span><br><span class=line></span><br><span class=line>asyncio.run(main())</span><br></pre></td></tr></table></figure><p>在上面的示例中，通过<code>asyncio.Lock()</code>创建了一个锁对象，然后在协程中使用<code>async with lock</code>来获取锁。这样可以保证同一时刻只有一个协程可以访问共享资源。</p><h4 id=5-2-指针锁与asyncio的解决方案><a href=#5-2-指针锁与asyncio的解决方案 class=headerlink title="5.2 指针锁与asyncio的解决方案"></a>5.2 指针锁与asyncio的解决方案</h4><p>在Python的<code>asyncio</code>模块中，并发控制通常通过<code>asyncio.Lock</code>来实现，而不是使用传统的指针锁。<code>asyncio.Lock</code><br>是基于协程的锁，可以在协程中使用<code>async with lock</code>语法来实现锁定和释放。</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>import</span> asyncio</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">task</span>(<span class=params>lock</span>):</span><br><span class=line>    <span class=keyword>async</span> <span class=keyword>with</span> lock:</span><br><span class=line>        <span class=comment># 访问共享资源的代码</span></span><br><span class=line>        <span class=built_in>print</span>(<span class=string>&quot;Accessing shared resource&quot;</span>)</span><br><span class=line>        <span class=keyword>await</span> asyncio.sleep(<span class=number>1</span>)</span><br><span class=line>        <span class=built_in>print</span>(<span class=string>&quot;Finished accessing shared resource&quot;</span>)</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">main</span>():</span><br><span class=line>    lock = asyncio.Lock()</span><br><span class=line>    tasks = [task(lock) <span class=keyword>for</span> _ <span class=keyword>in</span> <span class=built_in>range</span>(<span class=number>5</span>)]</span><br><span class=line>    <span class=keyword>await</span> asyncio.gather(*tasks)</span><br><span class=line></span><br><span class=line></span><br><span class=line>asyncio.run(main())</span><br></pre></td></tr></table></figure><h4 id=5-3-示例：并发访问共享资源的管理><a href=#5-3-示例：并发访问共享资源的管理 class=headerlink title="5.3 示例：并发访问共享资源的管理"></a>5.3 示例：并发访问共享资源的管理</h4><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>import</span> asyncio</span><br><span class=line></span><br><span class=line>shared_resource = <span class=number>0</span></span><br><span class=line>lock = asyncio.Lock()</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">update_shared_resource</span>():</span><br><span class=line>    <span class=keyword>global</span> shared_resource</span><br><span class=line>    <span class=keyword>async</span> <span class=keyword>with</span> lock:</span><br><span class=line>        shared_resource += <span class=number>1</span></span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">main</span>():</span><br><span class=line>    tasks = [update_shared_resource() <span class=keyword>for</span> _ <span class=keyword>in</span> <span class=built_in>range</span>(<span class=number>10</span>)]</span><br><span class=line>    <span class=keyword>await</span> asyncio.gather(*tasks)</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>f&quot;Final shared resource value: <span class=subst>&#123;shared_resource&#125;</span>&quot;</span>)</span><br><span class=line></span><br><span class=line></span><br><span class=line>asyncio.run(main())</span><br></pre></td></tr></table></figure><p>在这个示例中，多个协程同时更新共享资源<code>shared_resource</code>，通过<code>asyncio.Lock</code>实现并发控制，确保共享资源的安全访问。最终输出的共享资源值应为10，每个协程更新一次。</p><h2 id=第6章：协程的并发编程模式><a href=#第6章：协程的并发编程模式 class=headerlink title=第6章：协程的并发编程模式></a>第6章：协程的并发编程模式</h2><h4 id=6-1-协程链与流水线模式><a href=#6-1-协程链与流水线模式 class=headerlink title="6.1 协程链与流水线模式"></a>6.1 协程链与流水线模式</h4><p>协程链（Coroutine<br>Chain）是一种将多个协程按照顺序连接起来的并发编程模式，每个协程负责处理一部分任务。流水线模式（Pipeline）是协程链的一种特例，它将数据流通过一系列协程进行处理，每个协程只负责处理特定的数据处理步骤。</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>import</span> asyncio</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">coroutine1</span>(<span class=params>data</span>):</span><br><span class=line>    <span class=comment># 处理数据</span></span><br><span class=line>    <span class=built_in>print</span>(<span class=string>f&quot;Coroutinue1: <span class=subst>&#123;data&#125;</span>&quot;</span>)</span><br><span class=line>    <span class=keyword>await</span> asyncio.sleep(<span class=number>0.1</span>)</span><br><span class=line>    <span class=keyword>return</span> data * <span class=number>2</span></span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">coroutine2</span>(<span class=params>data</span>):</span><br><span class=line>    <span class=comment># 处理数据</span></span><br><span class=line>    <span class=built_in>print</span>(<span class=string>f&quot;Coroutinue2: <span class=subst>&#123;data&#125;</span>&quot;</span>)</span><br><span class=line>    <span class=keyword>await</span> asyncio.sleep(<span class=number>0.1</span>)</span><br><span class=line>    <span class=keyword>return</span> data ** <span class=number>2</span></span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">main</span>():</span><br><span class=line>    data = <span class=number>1</span></span><br><span class=line>    coroutines = [coroutine1, coroutine2]</span><br><span class=line>    <span class=keyword>for</span> coroutine <span class=keyword>in</span> coroutines:</span><br><span class=line>        data = <span class=keyword>await</span> coroutine(data)</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>f&quot;Final result: <span class=subst>&#123;data&#125;</span>&quot;</span>)</span><br><span class=line></span><br><span class=line></span><br><span class=line>asyncio.run(main())</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们创建了两个协程<code>coroutine1</code>和<code>coroutine2</code>，将它们按照顺序连接起来，形成一个协程链。数据在协程链中流动，每个协程负责处理特定的数据处理步骤。</p><h4 id=6-2-基于协程的事件驱动架构><a href=#6-2-基于协程的事件驱动架构 class=headerlink title="6.2 基于协程的事件驱动架构"></a>6.2 基于协程的事件驱动架构</h4><p>事件驱动架构（Event-Driven Architecture）是一种基于事件的并发编程模式，它将应用程序分解为多个独立的事件处理器，每个事件处理器负责处理特定的事件。当事件发生时，事件处理器会被激活并执行相应的处理逻辑。</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>import</span> asyncio</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">handle_event</span>(<span class=params>event</span>):</span><br><span class=line>    <span class=comment># 处理事件</span></span><br><span class=line>    <span class=built_in>print</span>(<span class=string>f&quot;Handling event: <span class=subst>&#123;event&#125;</span>&quot;</span>)</span><br><span class=line>    <span class=keyword>await</span> asyncio.sleep(<span class=number>0.1</span>)</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">main</span>():</span><br><span class=line>    events = [<span class=string>&quot;event1&quot;</span>, <span class=string>&quot;event2&quot;</span>, <span class=string>&quot;event3&quot;</span>]</span><br><span class=line>    tasks = [handle_event(event) <span class=keyword>for</span> event <span class=keyword>in</span> events]</span><br><span class=line>    <span class=keyword>await</span> asyncio.gather(*tasks)</span><br><span class=line></span><br><span class=line></span><br><span class=line>asyncio.run(main())</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个<code>handle_event</code>协程来处理事件。在<code>main</code>函数中，我们创建了三个事件<code>event1</code>、<code>event2</code>和<code>event3</code><br>，然后为每个事件创建一个任务，并使用<code>asyncio.gather</code>同时运行这些任务。这样，基于协程的事件驱动架构可以实现并发处理多个事件。</p><h4 id=6-3-示例：基于协程的实时数据处理><a href=#6-3-示例：基于协程的实时数据处理 class=headerlink title="6.3 示例：基于协程的实时数据处理"></a>6.3 示例：基于协程的实时数据处理</h4><p>基于协程的实时数据处理是一种利用协程实现数据流处理的并发编程模式，可以实现高效的数据处理和实时响应。</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>import</span> asyncio</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">process_data</span>(<span class=params>data</span>):</span><br><span class=line>    <span class=comment># 处理数据</span></span><br><span class=line>    <span class=built_in>print</span>(<span class=string>f&quot;Processing data: <span class=subst>&#123;data&#125;</span>&quot;</span>)</span><br><span class=line>    <span class=keyword>await</span> asyncio.sleep(<span class=number>0.1</span>)</span><br><span class=line>    <span class=keyword>return</span> data.upper()</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">main</span>():</span><br><span class=line>    data_stream = [<span class=string>&quot;data1&quot;</span>, <span class=string>&quot;data2&quot;</span>, <span class=string>&quot;data3&quot;</span>]</span><br><span class=line>    tasks = [process_data(data) <span class=keyword>for</span> data <span class=keyword>in</span> data_stream]</span><br><span class=line>    processed_data = <span class=keyword>await</span> asyncio.gather(*tasks)</span><br><span class=line>    <span class=built_in>print</span>(<span class=string>f&quot;Processed data: <span class=subst>&#123;processed_data&#125;</span>&quot;</span>)</span><br><span class=line></span><br><span class=line></span><br><span class=line>asyncio.run(main())</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个<code>process_data</code>协程来处理数据。在<code>main</code>函数中，我们创建了一个数据流<code>data_stream</code><br>，并为每个数据创建一个处理任务。使用<code>asyncio.gather</code>可以同时运行这些处理任务，并等待它们完成。最终，我们可以得到处理后的数据流。</p><h2 id=第7章：实战项目：网络爬虫与Web应用><a href=#第7章：实战项目：网络爬虫与Web应用 class=headerlink title=第7章：实战项目：网络爬虫与Web应用></a>第7章：实战项目：网络爬虫与Web应用</h2><h4 id=7-1-爬虫中的协程调度><a href=#7-1-爬虫中的协程调度 class=headerlink title="7.1 爬虫中的协程调度"></a>7.1 爬虫中的协程调度</h4><p>在爬虫中使用协程可以提高爬取效率，协程调度可以使爬虫程序更加高效地处理多个任务。以下是一个简单的爬虫示例，使用协程和异步IO库<code>aiohttp</code>：</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>import</span> asyncio</span><br><span class=line><span class=keyword>import</span> aiohttp</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">fetch_url</span>(<span class=params>url</span>):</span><br><span class=line>    <span class=keyword>async</span> <span class=keyword>with</span> aiohttp.ClientSession() <span class=keyword>as</span> session:</span><br><span class=line>        <span class=keyword>async</span> <span class=keyword>with</span> session.get(url) <span class=keyword>as</span> response:</span><br><span class=line>            <span class=keyword>return</span> <span class=keyword>await</span> response.text()</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">main</span>():</span><br><span class=line>    urls = [<span class=string>&quot;http://example.com/page1&quot;</span>, <span class=string>&quot;http://example.com/page2&quot;</span>, <span class=string>&quot;http://example.com/page3&quot;</span>]</span><br><span class=line>    tasks = [fetch_url(url) <span class=keyword>for</span> url <span class=keyword>in</span> urls]</span><br><span class=line>    results = <span class=keyword>await</span> asyncio.gather(*tasks)</span><br><span class=line>    <span class=keyword>for</span> result <span class=keyword>in</span> results:</span><br><span class=line>        <span class=built_in>print</span>(result)</span><br><span class=line></span><br><span class=line></span><br><span class=line>asyncio.run(main())</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个<code>fetch_url</code>协程来获取URL的内容。在<code>main</code><br>函数中，我们创建了多个URL的任务，并使用<code>asyncio.gather</code>同时运行这些任务。这样，爬虫可以并发地获取多个URL的内容，提高爬取效率。</p><h4 id=7-2-基于协程的Web服务器构建><a href=#7-2-基于协程的Web服务器构建 class=headerlink title="7.2 基于协程的Web服务器构建"></a>7.2 基于协程的Web服务器构建</h4><p>使用协程可以构建高性能的Web服务器，以下是一个简单的基于协程的Web服务器示例：</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>from</span> aiohttp <span class=keyword>import</span> web</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">handle</span>(<span class=params>request</span>):</span><br><span class=line>    <span class=keyword>return</span> web.Response(text=<span class=string>&quot;Hello, World!&quot;</span>)</span><br><span class=line></span><br><span class=line></span><br><span class=line>app = web.Application()</span><br><span class=line>app.router.add_get(<span class=string>&#x27;/&#x27;</span>, handle)</span><br><span class=line></span><br><span class=line>web.run_app(app)</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个处理函数<code>handle</code>来处理HTTP请求，并创建了一个<code>web.Application</code>应用。通过<code>app.router.add_get</code><br>将处理函数绑定到根路径’&#x2F;‘，最后使用<code>web.run_app</code>来运行Web服务器。</p><h4 id=7-3-实战项目：构建一个简单的异步HTTP客户端><a href=#7-3-实战项目：构建一个简单的异步HTTP客户端 class=headerlink title="7.3 实战项目：构建一个简单的异步HTTP客户端"></a>7.3 实战项目：构建一个简单的异步HTTP客户端</h4><p>构建一个简单的异步HTTP客户端可以帮助我们实现高效的HTTP请求。以下是一个简单的异步HTTP客户端示例：</p><figure class="highlight python"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre></td><td class=code><pre><span class=line><span class=keyword>import</span> aiohttp</span><br><span class=line><span class=keyword>import</span> asyncio</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">fetch_url</span>(<span class=params>url</span>):</span><br><span class=line>    <span class=keyword>async</span> <span class=keyword>with</span> aiohttp.ClientSession() <span class=keyword>as</span> session:</span><br><span class=line>        <span class=keyword>async</span> <span class=keyword>with</span> session.get(url) <span class=keyword>as</span> response:</span><br><span class=line>            <span class=keyword>return</span> <span class=keyword>await</span> response.text()</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>async</span> <span class=keyword>def</span> <span class="title function_">main</span>():</span><br><span class=line>    url = <span class=string>&quot;http://example.com&quot;</span></span><br><span class=line>    response = <span class=keyword>await</span> fetch_url(url)</span><br><span class=line>    <span class=built_in>print</span>(response)</span><br><span class=line></span><br><span class=line></span><br><span class=line>asyncio.run(main())</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个<code>fetch_url</code>协程来获取URL的内容。在<code>main</code>函数中，我们发起了一个HTTP<br>GET请求，并等待响应。这样，我们可以实现异步地获取URL的内容。</p><h2 id=第8章：协程的未来与展望><a href=#第8章：协程的未来与展望 class=headerlink title=第8章：协程的未来与展望></a>第8章：协程的未来与展望</h2><h4 id=8-1-Python-3-7及以上版本的async-await改进><a href=#8-1-Python-3-7及以上版本的async-await改进 class=headerlink title="8.1 Python 3.7及以上版本的async&#x2F;await改进"></a>8.1 Python 3.7及以上版本的async&#x2F;await改进</h4><p>Python 3.7版本及以上版本对async&#x2F;await语法进行了改进，使得使用协程更加方便和高效。以下是一些Python<br>3.7及以上版本中async&#x2F;await语法的改进：</p><ul><li>支持<code>async with</code>和<code>async for</code>语句，使得使用协程可以更加方便和高效。</li><li>支持<code>async for</code>语句的<code>async for ... of</code>语法，使得在协程中使用生成器更加简单和高效。</li><li>支持<code>async def</code>语句，使得定义协程更加简单和直观。</li><li>支持<code>await</code>语句的<code>await expression</code>语法，使得在协程中等待异步操作更加简单和高效。</li><li>支持<code>asyncio</code>库中的<code>asyncio.run</code>函数，使得运行协程更加简单和高效。</li></ul><h4 id=8-2-协程在现代Python生态系统中的角色><a href=#8-2-协程在现代Python生态系统中的角色 class=headerlink title="8.2 协程在现代Python生态系统中的角色"></a>8.2 协程在现代Python生态系统中的角色</h4><p>在现代Python生态系ystem中，协程已经成为一个非常重要的并发编程模型。以下是协程在现代Python生态系统中的一些角色：</p><ul><li>网络爬虫：使用协程可以实现高效的网络爬虫，提高爬取效率。</li><li>Web应用：使用协程可以构建高性能的Web应用，提高响应速度。</li><li>异步IO：使用协程可以实现高效的异步IO操作，提高IO操作的效率。</li><li>数据处理：使用协程可以实现高效的数据处理，提高数据处理的速度。</li><li>分布式系统：使用协程可以构建高效的分布式系统，提高系统的可扩展性和可用性。</li></ul><h4 id=8-3-结语与进一步学习资源><a href=#8-3-结语与进一步学习资源 class=headerlink title="8.3 结语与进一步学习资源"></a>8.3 结语与进一步学习资源</h4><p>在本文中，我们介绍了协程的基本概念和使用方法，并结合实际案例展示了协程在实际应用中的优势和应用场景。如果您想进一步学习协程，可以参考以下资源：</p><ul><li>《Python Cookbook》一书中的<code>asyncio</code>和<code>aiohttp</code>章节。</li><li>《Python 3.7 新特性与改进》一文中的async&#x2F;await章节。</li><li>《Python 协程编程》一本电子书。</li><li>《Python asyncio 编程》一本电子书。</li><li>Python官方文档中的asyncio和aiohttp部分。</li></ul><h2 id=附录><a href=#附录 class=headerlink title=附录></a>附录</h2><h3 id=A-Python协程相关库和工具介绍><a href=#A-Python协程相关库和工具介绍 class=headerlink title="A. Python协程相关库和工具介绍"></a>A. Python协程相关库和工具介绍</h3><p><a class=link target=_blank rel=noopener href=https://amd794.com/ >首页 | 一个覆盖广泛主题工具的高效在线平台(amd794.com)<i class="fas fa-external-link-alt"></i></a></p><h4 id=asyncio><a href=#asyncio class=headerlink title=asyncio></a>asyncio</h4><p><code>asyncio</code>是Python 3.4版本引入的一个标准库，用于实现异步IO操作和并发编程。<code>asyncio</code><br>基于协程实现，提供了许多高级API和工具，使得开发人员可以快速构建高效的异步IO应用。</p><h4 id=aiohttp><a href=#aiohttp class=headerlink title=aiohttp></a>aiohttp</h4><p><code>aiohttp</code>是一个基于<code>asyncio</code>实现的异步HTTP客户端和服务器库。<code>aiohttp</code>支持协程，提供了许多高级API和工具，使得开发人员可以快速构建高效的异步Web应用。</p><h4 id=trio><a href=#trio class=headerlink title=trio></a>trio</h4><p><code>trio</code>是一个基于协程实现的异步IO操作和并发编程库，与<code>asyncio</code>类似，但提供了更加简单和高效的API和工具。<code>trio</code><br>支持多个事件循环，可以更加灵活和高效地管理协程。</p><h4 id=curio><a href=#curio class=headerlink title=curio></a>curio</h4><p><code>curio</code>是一个基于协程实现的异步IO操作和并发编程库，与<code>asyncio</code>类似，但提供了更加简单和高效的API和工具。<code>curio</code><br>支持多个事件循环，可以更加灵活和高效地管理协程。</p><h4 id=Sanic><a href=#Sanic class=headerlink title=Sanic></a>Sanic</h4><p><code>Sanic</code>是一个基于<code>aiohttp</code>实现的异步Web框架，支持协程，提供了许多高级API和工具，使得开发人员可以快速构建高效的异步Web应用。</p><h3 id=B-协程调试与性能优化><a href=#B-协程调试与性能优化 class=headerlink title="B. 协程调试与性能优化"></a>B. 协程调试与性能优化</h3><h4 id=调试><a href=#调试 class=headerlink title=调试></a>调试</h4><p>调试协程可能会比调试同步代码更加复杂，因为协程的执行流程更加复杂。以下是一些调试协程的技巧和工具：</p><ul><li>使用<code>pdb</code>调试器：<code>pdb</code>是Python的标准调试器，可以用于调试协程。</li><li>使用<code>asyncio</code>提供的<code>asyncio.get_event_loop()</code>函数获取当前事件循环，并使用<code>loop.run_until_complete()</code>函数运行协程。</li><li>使用<code>asyncio</code>提供的<code>asyncio.create_task()</code>函数创建一个新的任务，并使用<code>asyncio.gather()</code>函数等待所有任务完成。</li><li>使用<code>asyncio</code>提供的<code>asyncio.as_completed()</code>函数按照完成顺序获取任务的结果。</li><li>使用<code>asyncio</code>提供的<code>asyncio.wait()</code>函数等待所有任务完成，并获取完成和未完成的任务列表。</li></ul><h4 id=性能优化><a href=#性能优化 class=headerlink title=性能优化></a>性能优化</h4><p>优化协程的性能可能会比优化同步代码更加复杂，因为协程的执行流程更加复杂。以下是一些优化协程性能的技巧和工具：</p><ul><li>使用<code>asyncio.gather()</code>函数并行执行多个任务，提高IO操作的效率。</li><li>使用<code>asyncio.sleep()</code>函数减少CPU占用，提高IO操作的效率。</li><li>使用<code>asyncio.wait()</code>函数并行执行多个任务，并获取完成和未完成的任务列表，提高IO操作的效率。</li><li>使用<code>asyncio.as_completed()</code>函数按照完成顺序获取任务的结果，提高IO操作的效率。</li><li>使用<code>asyncio.Queue</code>和<code>asyncio.Semaphore</code>限制并发数，提高IO操作的效率。</li></ul><h3 id=C-常见问题解答><a href=#C-常见问题解答 class=headerlink title="C. 常见问题解答"></a>C. 常见问题解答</h3><h4 id=1-什么是协程？><a href=#1-什么是协程？ class=headerlink title="1. 什么是协程？"></a>1. 什么是协程？</h4><p>协程是一种轻量级的线程，可以在单个线程中实现多个任务的并发执行。</p><h4 id=2-为什么使用协程？><a href=#2-为什么使用协程？ class=headerlink title="2. 为什么使用协程？"></a>2. 为什么使用协程？</h4><p>使用协程可以实现高效的异步IO操作和并发编程，提高IO操作的效率。</p><h4 id=3-如何使用协程？><a href=#3-如何使用协程？ class=headerlink title="3. 如何使用协程？"></a>3. 如何使用协程？</h4><p>使用协程需要使用<code>async</code>和<code>await</code>关键字，定义一个协程函数，并使用<code>asyncio</code>库中的<code>asyncio.run()</code>函数运行协程。</p><h4 id=4-如何在协程中等待异步操作？><a href=#4-如何在协程中等待异步操作？ class=headerlink title="4. 如何在协程中等待异步操作？"></a>4. 如何在协程中等待异步操作？</h4><p>使用<code>await</code>关键字可以在协程中等待异步操作，直到操作完成。</p><h4 id=5-如何在协程中创建一个新的任务？><a href=#5-如何在协程中创建一个新的任务？ class=headerlink title="5. 如何在协程中创建一个新的任务？"></a>5. 如何在协程中创建一个新的任务？</h4><p>使用<code>asyncio.create_task()</code>函数可以在协程中创建一个新的任务。</p><h4 id=6-如何在协程中等待多个任务完成？><a href=#6-如何在协程中等待多个任务完成？ class=headerlink title="6. 如何在协程中等待多个任务完成？"></a>6. 如何在协程中等待多个任务完成？</h4><p>使用<code>asyncio.gather()</code>函数可以在协程中等待多个任务完成。</p><h4 id=7-如何在协程中获取完成的任务结果？><a href=#7-如何在协程中获取完成的任务结果？ class=headerlink title="7. 如何在协程中获取完成的任务结果？"></a>7. 如何在协程中获取完成的任务结果？</h4><p>使用<code>asyncio.as_completed()</code>函数可以在协程中按照完成顺序获取任务的结果。</p><h4 id=8-如何在协程中限制并发数？><a href=#8-如何在协程中限制并发数？ class=headerlink title="8. 如何在协程中限制并发数？"></a>8. 如何在协程中限制并发数？</h4><p>使用<code>asyncio.Queue</code>和<code>asyncio.Semaphore</code>可以在协程中限制并发数。</p><h4 id=9-如何调试协程？><a href=#9-如何调试协程？ class=headerlink title="9. 如何调试协程？"></a>9. 如何调试协程？</h4><p>使用<code>pdb</code>调试器、<code>asyncio.get_event_loop()</code>函数、<code>asyncio.create_task()</code>函数、<code>asyncio.gather()</code><br>函数、<code>asyncio.as_completed()</code>函数和<code>asyncio.wait()</code>函数可以调试协程。</p><h4 id=10-如何优化协程性能？><a href=#10-如何优化协程性能？ class=headerlink title="10. 如何优化协程性能？"></a>10. 如何优化协程性能？</h4><p>使用<code>asyncio.gather()</code>函数、<code>asyncio.sleep()</code>函数、<code>asyncio.wait()</code>函数、<code>asyncio.as_completed()</code>函数和<code>asyncio.Queue</code><br>和<code>asyncio.Semaphore</code>可以优化协程性能。</p><h4 id=11-如何在协程中处理异常？><a href=#11-如何在协程中处理异常？ class=headerlink title="11. 如何在协程中处理异常？"></a>11. 如何在协程中处理异常？</h4><p>使用<code>try</code>和<code>except</code>语句可以在协程中处理异常。如果在协程中发生异常，可以使用<code>asyncio.exceptions.AsyncioFuture.get_result()</code><br>函数获取异常信息。</p><h4 id=12-如何在协程中实现超时？><a href=#12-如何在协程中实现超时？ class=headerlink title="12. 如何在协程中实现超时？"></a>12. 如何在协程中实现超时？</h4><p>使用<code>asyncio.wait_for()</code>函数可以在协程中实现超时。如果在超时时间内未完成，可以使用<code>asyncio.wait_for()</code>函数中的<code>timeout</code><br>参数设置超时时间。</p><h4 id=13-如何在协程中实现定时任务？><a href=#13-如何在协程中实现定时任务？ class=headerlink title="13. 如何在协程中实现定时任务？"></a>13. 如何在协程中实现定时任务？</h4><p>使用<code>asyncio.create_task()</code>函数和<code>asyncio.sleep()</code><br>函数可以在协程中实现定时任务。可以在协程中创建一个新的任务，并使用<code>asyncio.sleep()</code>函数设置定时时间。</p><h4 id=14-如何在协程中实现循环任务？><a href=#14-如何在协程中实现循环任务？ class=headerlink title="14. 如何在协程中实现循环任务？"></a>14. 如何在协程中实现循环任务？</h4><p>使用<code>asyncio.create_task()</code>函数和<code>asyncio.sleep()</code><br>函数可以在协程中实现循环任务。可以在协程中创建一个新的任务，并使用<code>asyncio.sleep()</code>函数设置循环时间。</p><h4 id=15-如何在协程中实现并发限制？><a href=#15-如何在协程中实现并发限制？ class=headerlink title="15. 如何在协程中实现并发限制？"></a>15. 如何在协程中实现并发限制？</h4><p>使用<code>asyncio.Semaphore</code>可以在协程中实现并发限制。可以在协程中创建一个<code>asyncio.Semaphore</code><br>对象，并使用<code>asyncio.Semaphore.acquire()</code>函数获取信号量，使用<code>asyncio.Semaphore.release()</code>函数释放信号量。</p><h4 id=16-如何在协程中实现任务优先级？><a href=#16-如何在协程中实现任务优先级？ class=headerlink title="16. 如何在协程中实现任务优先级？"></a>16. 如何在协程中实现任务优先级？</h4><p>使用<code>asyncio.PriorityQueue</code>可以在协程中实现任务优先级。可以在协程中创建一个<code>asyncio.PriorityQueue</code><br>对象，并使用<code>asyncio.PriorityQueue.put()</code>函数添加任务，使用<code>asyncio.PriorityQueue.get()</code>函数获取优先级最高的任务。</p><h4 id=17-如何在协程中实现任务取消？><a href=#17-如何在协程中实现任务取消？ class=headerlink title="17. 如何在协程中实现任务取消？"></a>17. 如何在协程中实现任务取消？</h4><p>使用<code>asyncio.create_task()</code>函数和<code>asyncio.Task.cancel()</code><br>函数可以在协程中实现任务取消。可以在协程中创建一个新的任务，并使用<code>asyncio.Task.cancel()</code>函数取消任务。</p><h4 id=18-如何在协程中实现任务超时？><a href=#18-如何在协程中实现任务超时？ class=headerlink title="18. 如何在协程中实现任务超时？"></a>18. 如何在协程中实现任务超时？</h4><p>使用<code>asyncio.wait_for()</code>函数和<code>asyncio.Task.cancel()</code><br>函数可以在协程中实现任务超时。可以在协程中创建一个新的任务，并使用<code>asyncio.wait_for()</code><br>函数设置超时时间，如果在超时时间内未完成，可以使用<code>asyncio.Task.cancel()</code>函数取消任务。</p><h4 id=19-如何在协程中实现任务队列？><a href=#19-如何在协程中实现任务队列？ class=headerlink title="19. 如何在协程中实现任务队列？"></a>19. 如何在协程中实现任务队列？</h4><p>使用<code>asyncio.Queue</code>可以在协程中实现任务队列。可以在协程中创建一个<code>asyncio.Queue</code>对象，并使用<code>asyncio.Queue.put()</code><br>函数添加任务，使用<code>asyncio.Queue.get()</code>函数获取任务。</p><h4 id=20-如何在协程中实现任务分组？><a href=#20-如何在协程中实现任务分组？ class=headerlink title="20. 如何在协程中实现任务分组？"></a>20. 如何在协程中实现任务分组？</h4><p>使用<code>asyncio.gather()</code>函数可以在协程中实现任务分组。可以在协程中使用<code>asyncio.gather()</code><br>函数分组多个任务，并使用<code>asyncio.gather()</code>函数中的<code>return_exceptions</code>参数设置是否返回异常信息。</p></div><script>"undefined"!=typeof Prism&&"undefined"!=typeof mermaid&&mermaid.initialize({startOnLoad:!0,theme:"dark"===document.documentElement.getAttribute("data-theme")?"dark":"default"})</script><div class="post-copyright-info-container border-box"><div class="copyright-info-content border-box"><div class="copyright-info-top border-box"><div class="copyright-post-title border-box text-ellipsis">深入理解Python协程：从基础到实战</div><div class="copyright-post-link border-box text-ellipsis">2024/04/27/back_end/深入理解python协程：从基础到实战/</div></div><div class="copyright-info-bottom border-box"><div class="copyright-post-author bottom-item"><div class=type>作者</div><div class=content>cmdragon</div></div><div class="post-time bottom-item"><div class=type>发布于</div><div class=content>2024-04-27 16:48</div></div><div class="post-license bottom-item"><div class=type>许可</div><div class="content tooltip" data-tooltip-content="CC BY-NC-SA 4.0"><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed target=_blank><i class="fa-brands fa-creative-commons"></i> <i class="fa-brands fa-creative-commons-by"></i> <i class="fa-brands fa-creative-commons-nc"></i> <i class="fa-brands fa-creative-commons-sa"></i></a></div></div></div><i class="copyright-bg fa-solid fa-copyright"></i></div><div class="copy-copyright-info flex-center tooltip" data-tooltip-content=复制版权信息 data-tooltip-offset-y=-2px><i class="fa-solid fa-copy"></i></div></div><div class="post-bottom-tags-and-share border-box"><div><ul class="post-tags-box border-box"><li class="tag-item border-box"><i class="icon fas fa-hashtag"></i>&nbsp;<a href=/tags/%E5%8D%8F%E7%A8%8B/ >协程</a></li><li class="tag-item border-box"><i class="icon fas fa-hashtag"></i>&nbsp;<a href=/tags/%E5%BC%82%E6%AD%A5IO/ >异步IO</a></li><li class="tag-item border-box"><i class="icon fas fa-hashtag"></i>&nbsp;<a href=/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ >并发编程</a></li><li class="tag-item border-box"><i class="icon fas fa-hashtag"></i>&nbsp;<a href=/tags/Python/ >Python</a></li><li class="tag-item border-box"><i class="icon fas fa-hashtag"></i>&nbsp;<a href=/tags/aiohttp/ >aiohttp</a></li><li class="tag-item border-box"><i class="icon fas fa-hashtag"></i>&nbsp;<a href=/tags/asyncio/ >asyncio</a></li><li class="tag-item border-box"><i class="icon fas fa-hashtag"></i>&nbsp;<a href=/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/ >网络爬虫</a></li></ul></div><div><div class="post-share-container border-box"><ul class="share-list-wrap border-box"><li class="qq share-item border-box flex-center tooltip" data-tooltip-content="分享到 QQ"><i class="fa-brands fa-qq"></i></li><li class="wechat share-item border-box flex-center tooltip tooltip-img" data-tooltip-content=分享到微信 data-tooltip-img-tip=微信扫一扫 data-tooltip-img-style="background-color: #fff; top: -10px; padding: 0.6rem 0.6rem 0.1rem 0.6rem;"><i class="fa-brands fa-weixin"></i></li><li class="weibo share-item border-box flex-center tooltip" data-tooltip-content=分享到微博><i class="fa-brands fa-weibo"></i></li></ul></div></div></div><div class="reward-author-container border-box flex-center"><div class="reward-btn keep-button border-box flex-center tooltip tooltip-img" data-tooltip-content=打赏作者一包辣条！ data-tooltip-img-url=/images/payment.jpg data-tooltip-img-trigger=click data-tooltip-img-style="top: -8px;"><i class="fa-solid fa-hand-holding-heart"></i></div></div><div class="post-nav border-box"><div class=prev-post><a class=prev rel=prev href=/2024/04/28/back_end/django/python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/ title=Python多线程编程深度探索：从入门到实战><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item text-ellipsis">Python多线程编程深度探索：从入门到实战</span> <span class=post-nav-item>上一篇</span></span></a></div><div class=next-post><a class=next rel=next href=/2024/04/26/back_end/django/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B%EF%BC%9A%E5%8E%9F%E7%90%86%E3%80%81%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8/ title=多进程编程：原理、技术与应用><span class="title flex-center"><span class="post-nav-title-item text-ellipsis">多进程编程：原理、技术与应用</span> <span class=post-nav-item>下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div></div></div><div class="pc-post-toc right-toc"><div class="post-toc-wrap border-box"><div class="post-toc border-box"><ol class=nav><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%AC%AC1%E7%AB%A0%EF%BC%9A%E5%8D%8F%E7%A8%8B%E5%9F%BA%E7%A1%80><span class=nav-number>1.</span> <span class=nav-text>第1章：协程基础</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-%E5%8D%8F%E7%A8%8B%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D><span class=nav-number>1.1.</span> <span class=nav-text>1.1 协程概念介绍</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8Eyield%E7%9A%84%E5%8E%9F%E7%90%86><span class=nav-number>1.2.</span> <span class=nav-text>1.2 生成器与yield的原理</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-%E5%8D%8F%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB><span class=nav-number>1.3.</span> <span class=nav-text>1.3 协程与多线程&#x2F;多进程的区别</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#1-4-%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2><span class=nav-number>1.4.</span> <span class=nav-text>1.4 协程的生命周期与状态转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%AC%AC2%E7%AB%A0%EF%BC%9A%E5%8D%8F%E7%A8%8B%E5%AE%9E%E8%B7%B5%E5%9F%BA%E7%A1%80><span class=nav-number>2.</span> <span class=nav-text>第2章：协程实践基础</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-%E4%BD%BF%E7%94%A8asyncio%E5%BA%93><span class=nav-number>2.1.</span> <span class=nav-text>2.1 使用asyncio库</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E4%B8%8Easync-await><span class=nav-number>2.2.</span> <span class=nav-text>2.2 异步函数与async&#x2F;await</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#2-3-%E5%8D%8F%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E4%B8%8E%E8%B0%83%E5%BA%A6%E5%99%A8><span class=nav-number>2.3.</span> <span class=nav-text>2.3 协程的调度与调度器</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#2-4-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86><span class=nav-number>2.4.</span> <span class=nav-text>2.4 示例：网络请求的异步处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%AC%AC3%E7%AB%A0%EF%BC%9A%E5%8D%8F%E7%A8%8B%E7%9A%84%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8><span class=nav-number>3.</span> <span class=nav-text>第3章：协程的高级应用</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5><span class=nav-number>3.1.</span> <span class=nav-text>异步并发编程的基本概念</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BC%98%E5%8A%BF><span class=nav-number>3.1.1.</span> <span class=nav-text>1. 异步编程的概念和优势</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#2-%E5%8D%8F%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF><span class=nav-number>3.1.2.</span> <span class=nav-text>2. 协程是如何实现异步编程的关键技术</span></a></li></ol></li><li class="nav-item nav-level-3"><a class=nav-link href=#3-%E5%BC%82%E6%AD%A5%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%8E%E4%BB%BB%E5%8A%A1%E6%B1%A0><span class=nav-number>3.2.</span> <span class=nav-text>3. 异步事件循环与任务池</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-%E5%BC%82%E6%AD%A5%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%9C%E7%94%A8><span class=nav-number>3.2.1.</span> <span class=nav-text>1. 异步事件循环的原理和作用</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#2-%E4%BB%BB%E5%8A%A1%E6%B1%A0%E5%9C%A8%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7><span class=nav-number>3.2.2.</span> <span class=nav-text>2. 任务池在异步编程中的重要性</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#3-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8asyncio%E5%BA%93%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1%E9%9B%86%E5%90%88><span class=nav-number>3.2.3.</span> <span class=nav-text>3. 示例：使用asyncio库创建和管理任务集合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%8D%8F%E7%A8%8B%E6%B1%A0%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86><span class=nav-number>3.3.</span> <span class=nav-text>协程池与资源管理</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-%E5%8D%8F%E7%A8%8B%E6%B1%A0%E5%9C%A8%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5><span class=nav-number>3.3.1.</span> <span class=nav-text>1. 协程池在并发编程中的作用和优化策略</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#2-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7%E5%92%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%B5%84%E6%BA%90%E6%B3%84%E9%9C%B2><span class=nav-number>3.3.2.</span> <span class=nav-text>2. 资源管理的重要性和如何避免资源泄露</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#3-%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E7%AE%A1%E7%90%86%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8F%96%E6%B6%88%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86><span class=nav-number>3.3.3.</span> <span class=nav-text>3. 如何有效管理协程的取消和异常处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8><span class=nav-number>3.4.</span> <span class=nav-text>示例：使用协程实现高效的Web服务器</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD><span class=nav-number>3.4.1.</span> <span class=nav-text>1. 异步编程提高性能</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#2-%E4%BD%BF%E7%94%A8aiohttp%E6%9E%84%E5%BB%BA%E5%BC%82%E6%AD%A5Web%E6%9C%8D%E5%8A%A1%E5%99%A8><span class=nav-number>3.4.2.</span> <span class=nav-text>2. 使用aiohttp构建异步Web服务器</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#3-%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E3%80%81%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8C%E4%BB%BB%E5%8A%A1%E6%B1%A0%E7%9A%84%E5%8D%8F%E4%BD%9C><span class=nav-number>3.4.3.</span> <span class=nav-text>3. 异步请求处理、事件循环和任务池的协作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%AC%AC4%E7%AB%A0%EF%BC%9A%E5%8D%8F%E7%A8%8B%E4%B8%8E%E5%BC%82%E6%AD%A5IO><span class=nav-number>4.</span> <span class=nav-text>第4章：协程与异步IO</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#4-1-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E4%B8%8ESocket%E7%BC%96%E7%A8%8B%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86><span class=nav-number>4.0.1.</span> <span class=nav-text>4.1 文件操作与Socket编程的异步处理</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%9A><span class=nav-number>4.0.1.1.</span> <span class=nav-text>文件操作的异步处理：</span></a></li><li class="nav-item nav-level-5"><a class=nav-link href=#Socket%E7%BC%96%E7%A8%8B%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%9A><span class=nav-number>4.0.1.2.</span> <span class=nav-text>Socket编程的异步处理：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class=nav-link href=#4-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B><span class=nav-number>4.0.2.</span> <span class=nav-text>4.2 数据库操作的异步编程</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#4-3-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%BC%82%E6%AD%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E4%B8%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99><span class=nav-number>4.0.3.</span> <span class=nav-text>4.3 示例：异步数据库操作与文件读写</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%AC%AC5%E7%AB%A0%EF%BC%9A%E5%8D%8F%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6><span class=nav-number>5.</span> <span class=nav-text>第5章：协程与并发控制</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#5-1-%E9%94%81%E4%B8%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8><span class=nav-number>5.0.1.</span> <span class=nav-text>5.1 锁与同步原语在协程中的应用</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#5-2-%E6%8C%87%E9%92%88%E9%94%81%E4%B8%8Easyncio%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88><span class=nav-number>5.0.2.</span> <span class=nav-text>5.2 指针锁与asyncio的解决方案</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#5-3-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%E7%9A%84%E7%AE%A1%E7%90%86><span class=nav-number>5.0.3.</span> <span class=nav-text>5.3 示例：并发访问共享资源的管理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%AC%AC6%E7%AB%A0%EF%BC%9A%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F><span class=nav-number>6.</span> <span class=nav-text>第6章：协程的并发编程模式</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#6-1-%E5%8D%8F%E7%A8%8B%E9%93%BE%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%A8%A1%E5%BC%8F><span class=nav-number>6.0.1.</span> <span class=nav-text>6.1 协程链与流水线模式</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#6-2-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84><span class=nav-number>6.0.2.</span> <span class=nav-text>6.2 基于协程的事件驱动架构</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#6-3-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%9F%BA%E4%BA%8E%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E6%97%B6%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86><span class=nav-number>6.0.3.</span> <span class=nav-text>6.3 示例：基于协程的实时数据处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%AC%AC7%E7%AB%A0%EF%BC%9A%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%EF%BC%9A%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B8%8EWeb%E5%BA%94%E7%94%A8><span class=nav-number>7.</span> <span class=nav-text>第7章：实战项目：网络爬虫与Web应用</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#7-1-%E7%88%AC%E8%99%AB%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6><span class=nav-number>7.0.1.</span> <span class=nav-text>7.1 爬虫中的协程调度</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#7-2-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E7%A8%8B%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA><span class=nav-number>7.0.2.</span> <span class=nav-text>7.2 基于协程的Web服务器构建</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#7-3-%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%BC%82%E6%AD%A5HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF><span class=nav-number>7.0.3.</span> <span class=nav-text>7.3 实战项目：构建一个简单的异步HTTP客户端</span></a></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%AC%AC8%E7%AB%A0%EF%BC%9A%E5%8D%8F%E7%A8%8B%E7%9A%84%E6%9C%AA%E6%9D%A5%E4%B8%8E%E5%B1%95%E6%9C%9B><span class=nav-number>8.</span> <span class=nav-text>第8章：协程的未来与展望</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#8-1-Python-3-7%E5%8F%8A%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC%E7%9A%84async-await%E6%94%B9%E8%BF%9B><span class=nav-number>8.0.1.</span> <span class=nav-text>8.1 Python 3.7及以上版本的async&#x2F;await改进</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#8-2-%E5%8D%8F%E7%A8%8B%E5%9C%A8%E7%8E%B0%E4%BB%A3Python%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%A7%92%E8%89%B2><span class=nav-number>8.0.2.</span> <span class=nav-text>8.2 协程在现代Python生态系统中的角色</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#8-3-%E7%BB%93%E8%AF%AD%E4%B8%8E%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90><span class=nav-number>8.0.3.</span> <span class=nav-text>8.3 结语与进一步学习资源</span></a></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E9%99%84%E5%BD%95><span class=nav-number>9.</span> <span class=nav-text>附录</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#A-Python%E5%8D%8F%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%BA%93%E5%92%8C%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D><span class=nav-number>9.1.</span> <span class=nav-text>A. Python协程相关库和工具介绍</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#asyncio><span class=nav-number>9.1.1.</span> <span class=nav-text>asyncio</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#aiohttp><span class=nav-number>9.1.2.</span> <span class=nav-text>aiohttp</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#trio><span class=nav-number>9.1.3.</span> <span class=nav-text>trio</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#curio><span class=nav-number>9.1.4.</span> <span class=nav-text>curio</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#Sanic><span class=nav-number>9.1.5.</span> <span class=nav-text>Sanic</span></a></li></ol></li><li class="nav-item nav-level-3"><a class=nav-link href=#B-%E5%8D%8F%E7%A8%8B%E8%B0%83%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96><span class=nav-number>9.2.</span> <span class=nav-text>B. 协程调试与性能优化</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%B0%83%E8%AF%95><span class=nav-number>9.2.1.</span> <span class=nav-text>调试</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96><span class=nav-number>9.2.2.</span> <span class=nav-text>性能优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class=nav-link href=#C-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94><span class=nav-number>9.3.</span> <span class=nav-text>C. 常见问题解答</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E7%A8%8B%EF%BC%9F><span class=nav-number>9.3.1.</span> <span class=nav-text>1. 什么是协程？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%EF%BC%9F><span class=nav-number>9.3.2.</span> <span class=nav-text>2. 为什么使用协程？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#3-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%EF%BC%9F><span class=nav-number>9.3.3.</span> <span class=nav-text>3. 如何使用协程？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#4-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E7%AD%89%E5%BE%85%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%EF%BC%9F><span class=nav-number>9.3.4.</span> <span class=nav-text>4. 如何在协程中等待异步操作？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#5-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E4%BB%BB%E5%8A%A1%EF%BC%9F><span class=nav-number>9.3.5.</span> <span class=nav-text>5. 如何在协程中创建一个新的任务？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#6-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E7%AD%89%E5%BE%85%E5%A4%9A%E4%B8%AA%E4%BB%BB%E5%8A%A1%E5%AE%8C%E6%88%90%EF%BC%9F><span class=nav-number>9.3.6.</span> <span class=nav-text>6. 如何在协程中等待多个任务完成？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#7-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%AE%8C%E6%88%90%E7%9A%84%E4%BB%BB%E5%8A%A1%E7%BB%93%E6%9E%9C%EF%BC%9F><span class=nav-number>9.3.7.</span> <span class=nav-text>7. 如何在协程中获取完成的任务结果？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#8-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E9%99%90%E5%88%B6%E5%B9%B6%E5%8F%91%E6%95%B0%EF%BC%9F><span class=nav-number>9.3.8.</span> <span class=nav-text>8. 如何在协程中限制并发数？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#9-%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%8D%8F%E7%A8%8B%EF%BC%9F><span class=nav-number>9.3.9.</span> <span class=nav-text>9. 如何调试协程？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#10-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%8D%8F%E7%A8%8B%E6%80%A7%E8%83%BD%EF%BC%9F><span class=nav-number>9.3.10.</span> <span class=nav-text>10. 如何优化协程性能？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#11-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%EF%BC%9F><span class=nav-number>9.3.11.</span> <span class=nav-text>11. 如何在协程中处理异常？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#12-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%AE%9E%E7%8E%B0%E8%B6%85%E6%97%B6%EF%BC%9F><span class=nav-number>9.3.12.</span> <span class=nav-text>12. 如何在协程中实现超时？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#13-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%9F><span class=nav-number>9.3.13.</span> <span class=nav-text>13. 如何在协程中实现定时任务？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#14-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E4%BB%BB%E5%8A%A1%EF%BC%9F><span class=nav-number>9.3.14.</span> <span class=nav-text>14. 如何在协程中实现循环任务？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#15-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E9%99%90%E5%88%B6%EF%BC%9F><span class=nav-number>9.3.15.</span> <span class=nav-text>15. 如何在协程中实现并发限制？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#16-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F><span class=nav-number>9.3.16.</span> <span class=nav-text>16. 如何在协程中实现任务优先级？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#17-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E5%8F%96%E6%B6%88%EF%BC%9F><span class=nav-number>9.3.17.</span> <span class=nav-text>17. 如何在协程中实现任务取消？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#18-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E8%B6%85%E6%97%B6%EF%BC%9F><span class=nav-number>9.3.18.</span> <span class=nav-text>18. 如何在协程中实现任务超时？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#19-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%EF%BC%9F><span class=nav-number>9.3.19.</span> <span class=nav-text>19. 如何在协程中实现任务队列？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#20-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E5%88%86%E7%BB%84%EF%BC%9F><span class=nav-number>9.3.20.</span> <span class=nav-text>20. 如何在协程中实现任务分组？</span></a></li></ol></li></ol></li></div></div></div></div></div></div></div><div class="page-main-content-bottom border-box"><footer class="footer border-box"><div class="copyright-info info-item">&copy;&nbsp;<span>2023</span>&nbsp;-&nbsp;2025 &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a target=_blank rel=noopener href=https://stats.uptimerobot.com/9mwrCwss4f>All systems status</a></div><div class="theme-info info-item">由&nbsp;<a target=_blank href=/ >Hexo</a>&nbsp;驱动&nbsp;&&nbsp;主题&nbsp;<a class=keep-version target=_blank href=/ >Keep</a></div><div class="deploy-info info-item"><a target=_blank rel=nofollow href=https://tools.cmdragon.cn/ >本站由 <span class=tooltip data-tooltip-content="GitHub Pages"><img src=/images/brands/github.png alt=deploy></span>提供部署服务</a></div></footer></div></div><div class="post-tools right-toc"><div class="post-tools-container border-box"><ul class="tools-list border-box"><li class="tools-item flex-center toggle-show-toc"><i class="fas fa-list"></i></li><li class="tools-item flex-center full-screen"><i class="fa-solid fa-expand"></i></li></ul></div></div><div class=side-tools><div class="side-tools-container border-box"><ul class="side-tools-list side-tools-show-handle border-box"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-toggle-theme-mode flex-center"><i class="fas fa-moon"></i></li><li class="tools-item rss flex-center"><a class=flex-center href=/atom.xml target=_blank><i class="fas fa-rss"></i></a></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list border-box"><li class="tools-item toggle-show-toc-tablet flex-center"><i class="fas fa-list"></i></li><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center show-arrow"><i class="arrow fas fa-arrow-up"></i> <span class=percent></span></li></ul></div></div><div class=zoom-in-image-mask><img class=zoom-in-image></div><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-input-field-pre><i class="fas fa-keyboard"></i></span><div class=search-input-container><input autocomplete=off autocorrect=off autocapitalize=off placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=close-popup-btn><i class="fas fa-times"></i></span></div><div id=search-result><div id=no-result><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div><div class=tablet-post-toc-mask><div class=tablet-post-toc><div class="post-toc-wrap border-box"><div class="post-toc border-box"><ol class=nav><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%AC%AC1%E7%AB%A0%EF%BC%9A%E5%8D%8F%E7%A8%8B%E5%9F%BA%E7%A1%80><span class=nav-number>1.</span> <span class=nav-text>第1章：协程基础</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-%E5%8D%8F%E7%A8%8B%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D><span class=nav-number>1.1.</span> <span class=nav-text>1.1 协程概念介绍</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8Eyield%E7%9A%84%E5%8E%9F%E7%90%86><span class=nav-number>1.2.</span> <span class=nav-text>1.2 生成器与yield的原理</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-%E5%8D%8F%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB><span class=nav-number>1.3.</span> <span class=nav-text>1.3 协程与多线程&#x2F;多进程的区别</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#1-4-%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2><span class=nav-number>1.4.</span> <span class=nav-text>1.4 协程的生命周期与状态转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%AC%AC2%E7%AB%A0%EF%BC%9A%E5%8D%8F%E7%A8%8B%E5%AE%9E%E8%B7%B5%E5%9F%BA%E7%A1%80><span class=nav-number>2.</span> <span class=nav-text>第2章：协程实践基础</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-%E4%BD%BF%E7%94%A8asyncio%E5%BA%93><span class=nav-number>2.1.</span> <span class=nav-text>2.1 使用asyncio库</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E4%B8%8Easync-await><span class=nav-number>2.2.</span> <span class=nav-text>2.2 异步函数与async&#x2F;await</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#2-3-%E5%8D%8F%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E4%B8%8E%E8%B0%83%E5%BA%A6%E5%99%A8><span class=nav-number>2.3.</span> <span class=nav-text>2.3 协程的调度与调度器</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#2-4-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86><span class=nav-number>2.4.</span> <span class=nav-text>2.4 示例：网络请求的异步处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%AC%AC3%E7%AB%A0%EF%BC%9A%E5%8D%8F%E7%A8%8B%E7%9A%84%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8><span class=nav-number>3.</span> <span class=nav-text>第3章：协程的高级应用</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5><span class=nav-number>3.1.</span> <span class=nav-text>异步并发编程的基本概念</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BC%98%E5%8A%BF><span class=nav-number>3.1.1.</span> <span class=nav-text>1. 异步编程的概念和优势</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#2-%E5%8D%8F%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF><span class=nav-number>3.1.2.</span> <span class=nav-text>2. 协程是如何实现异步编程的关键技术</span></a></li></ol></li><li class="nav-item nav-level-3"><a class=nav-link href=#3-%E5%BC%82%E6%AD%A5%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E4%B8%8E%E4%BB%BB%E5%8A%A1%E6%B1%A0><span class=nav-number>3.2.</span> <span class=nav-text>3. 异步事件循环与任务池</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-%E5%BC%82%E6%AD%A5%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%9C%E7%94%A8><span class=nav-number>3.2.1.</span> <span class=nav-text>1. 异步事件循环的原理和作用</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#2-%E4%BB%BB%E5%8A%A1%E6%B1%A0%E5%9C%A8%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7><span class=nav-number>3.2.2.</span> <span class=nav-text>2. 任务池在异步编程中的重要性</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#3-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8asyncio%E5%BA%93%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1%E9%9B%86%E5%90%88><span class=nav-number>3.2.3.</span> <span class=nav-text>3. 示例：使用asyncio库创建和管理任务集合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%8D%8F%E7%A8%8B%E6%B1%A0%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86><span class=nav-number>3.3.</span> <span class=nav-text>协程池与资源管理</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-%E5%8D%8F%E7%A8%8B%E6%B1%A0%E5%9C%A8%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5><span class=nav-number>3.3.1.</span> <span class=nav-text>1. 协程池在并发编程中的作用和优化策略</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#2-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7%E5%92%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%B5%84%E6%BA%90%E6%B3%84%E9%9C%B2><span class=nav-number>3.3.2.</span> <span class=nav-text>2. 资源管理的重要性和如何避免资源泄露</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#3-%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E7%AE%A1%E7%90%86%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8F%96%E6%B6%88%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86><span class=nav-number>3.3.3.</span> <span class=nav-text>3. 如何有效管理协程的取消和异常处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8><span class=nav-number>3.4.</span> <span class=nav-text>示例：使用协程实现高效的Web服务器</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD><span class=nav-number>3.4.1.</span> <span class=nav-text>1. 异步编程提高性能</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#2-%E4%BD%BF%E7%94%A8aiohttp%E6%9E%84%E5%BB%BA%E5%BC%82%E6%AD%A5Web%E6%9C%8D%E5%8A%A1%E5%99%A8><span class=nav-number>3.4.2.</span> <span class=nav-text>2. 使用aiohttp构建异步Web服务器</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#3-%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E3%80%81%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8C%E4%BB%BB%E5%8A%A1%E6%B1%A0%E7%9A%84%E5%8D%8F%E4%BD%9C><span class=nav-number>3.4.3.</span> <span class=nav-text>3. 异步请求处理、事件循环和任务池的协作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%AC%AC4%E7%AB%A0%EF%BC%9A%E5%8D%8F%E7%A8%8B%E4%B8%8E%E5%BC%82%E6%AD%A5IO><span class=nav-number>4.</span> <span class=nav-text>第4章：协程与异步IO</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#4-1-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E4%B8%8ESocket%E7%BC%96%E7%A8%8B%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86><span class=nav-number>4.0.1.</span> <span class=nav-text>4.1 文件操作与Socket编程的异步处理</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%9A><span class=nav-number>4.0.1.1.</span> <span class=nav-text>文件操作的异步处理：</span></a></li><li class="nav-item nav-level-5"><a class=nav-link href=#Socket%E7%BC%96%E7%A8%8B%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%9A><span class=nav-number>4.0.1.2.</span> <span class=nav-text>Socket编程的异步处理：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class=nav-link href=#4-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B><span class=nav-number>4.0.2.</span> <span class=nav-text>4.2 数据库操作的异步编程</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#4-3-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%BC%82%E6%AD%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E4%B8%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99><span class=nav-number>4.0.3.</span> <span class=nav-text>4.3 示例：异步数据库操作与文件读写</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%AC%AC5%E7%AB%A0%EF%BC%9A%E5%8D%8F%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6><span class=nav-number>5.</span> <span class=nav-text>第5章：协程与并发控制</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#5-1-%E9%94%81%E4%B8%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8><span class=nav-number>5.0.1.</span> <span class=nav-text>5.1 锁与同步原语在协程中的应用</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#5-2-%E6%8C%87%E9%92%88%E9%94%81%E4%B8%8Easyncio%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88><span class=nav-number>5.0.2.</span> <span class=nav-text>5.2 指针锁与asyncio的解决方案</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#5-3-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%E7%9A%84%E7%AE%A1%E7%90%86><span class=nav-number>5.0.3.</span> <span class=nav-text>5.3 示例：并发访问共享资源的管理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%AC%AC6%E7%AB%A0%EF%BC%9A%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F><span class=nav-number>6.</span> <span class=nav-text>第6章：协程的并发编程模式</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#6-1-%E5%8D%8F%E7%A8%8B%E9%93%BE%E4%B8%8E%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%A8%A1%E5%BC%8F><span class=nav-number>6.0.1.</span> <span class=nav-text>6.1 协程链与流水线模式</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#6-2-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84><span class=nav-number>6.0.2.</span> <span class=nav-text>6.2 基于协程的事件驱动架构</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#6-3-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%9F%BA%E4%BA%8E%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E6%97%B6%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86><span class=nav-number>6.0.3.</span> <span class=nav-text>6.3 示例：基于协程的实时数据处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%AC%AC7%E7%AB%A0%EF%BC%9A%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%EF%BC%9A%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B8%8EWeb%E5%BA%94%E7%94%A8><span class=nav-number>7.</span> <span class=nav-text>第7章：实战项目：网络爬虫与Web应用</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#7-1-%E7%88%AC%E8%99%AB%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6><span class=nav-number>7.0.1.</span> <span class=nav-text>7.1 爬虫中的协程调度</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#7-2-%E5%9F%BA%E4%BA%8E%E5%8D%8F%E7%A8%8B%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA><span class=nav-number>7.0.2.</span> <span class=nav-text>7.2 基于协程的Web服务器构建</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#7-3-%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%BC%82%E6%AD%A5HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF><span class=nav-number>7.0.3.</span> <span class=nav-text>7.3 实战项目：构建一个简单的异步HTTP客户端</span></a></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%AC%AC8%E7%AB%A0%EF%BC%9A%E5%8D%8F%E7%A8%8B%E7%9A%84%E6%9C%AA%E6%9D%A5%E4%B8%8E%E5%B1%95%E6%9C%9B><span class=nav-number>8.</span> <span class=nav-text>第8章：协程的未来与展望</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#8-1-Python-3-7%E5%8F%8A%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC%E7%9A%84async-await%E6%94%B9%E8%BF%9B><span class=nav-number>8.0.1.</span> <span class=nav-text>8.1 Python 3.7及以上版本的async&#x2F;await改进</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#8-2-%E5%8D%8F%E7%A8%8B%E5%9C%A8%E7%8E%B0%E4%BB%A3Python%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%A7%92%E8%89%B2><span class=nav-number>8.0.2.</span> <span class=nav-text>8.2 协程在现代Python生态系统中的角色</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#8-3-%E7%BB%93%E8%AF%AD%E4%B8%8E%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90><span class=nav-number>8.0.3.</span> <span class=nav-text>8.3 结语与进一步学习资源</span></a></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E9%99%84%E5%BD%95><span class=nav-number>9.</span> <span class=nav-text>附录</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#A-Python%E5%8D%8F%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%BA%93%E5%92%8C%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D><span class=nav-number>9.1.</span> <span class=nav-text>A. Python协程相关库和工具介绍</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#asyncio><span class=nav-number>9.1.1.</span> <span class=nav-text>asyncio</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#aiohttp><span class=nav-number>9.1.2.</span> <span class=nav-text>aiohttp</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#trio><span class=nav-number>9.1.3.</span> <span class=nav-text>trio</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#curio><span class=nav-number>9.1.4.</span> <span class=nav-text>curio</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#Sanic><span class=nav-number>9.1.5.</span> <span class=nav-text>Sanic</span></a></li></ol></li><li class="nav-item nav-level-3"><a class=nav-link href=#B-%E5%8D%8F%E7%A8%8B%E8%B0%83%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96><span class=nav-number>9.2.</span> <span class=nav-text>B. 协程调试与性能优化</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%B0%83%E8%AF%95><span class=nav-number>9.2.1.</span> <span class=nav-text>调试</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96><span class=nav-number>9.2.2.</span> <span class=nav-text>性能优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class=nav-link href=#C-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94><span class=nav-number>9.3.</span> <span class=nav-text>C. 常见问题解答</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E7%A8%8B%EF%BC%9F><span class=nav-number>9.3.1.</span> <span class=nav-text>1. 什么是协程？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%EF%BC%9F><span class=nav-number>9.3.2.</span> <span class=nav-text>2. 为什么使用协程？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#3-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%EF%BC%9F><span class=nav-number>9.3.3.</span> <span class=nav-text>3. 如何使用协程？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#4-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E7%AD%89%E5%BE%85%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%EF%BC%9F><span class=nav-number>9.3.4.</span> <span class=nav-text>4. 如何在协程中等待异步操作？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#5-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E4%BB%BB%E5%8A%A1%EF%BC%9F><span class=nav-number>9.3.5.</span> <span class=nav-text>5. 如何在协程中创建一个新的任务？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#6-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E7%AD%89%E5%BE%85%E5%A4%9A%E4%B8%AA%E4%BB%BB%E5%8A%A1%E5%AE%8C%E6%88%90%EF%BC%9F><span class=nav-number>9.3.6.</span> <span class=nav-text>6. 如何在协程中等待多个任务完成？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#7-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%AE%8C%E6%88%90%E7%9A%84%E4%BB%BB%E5%8A%A1%E7%BB%93%E6%9E%9C%EF%BC%9F><span class=nav-number>9.3.7.</span> <span class=nav-text>7. 如何在协程中获取完成的任务结果？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#8-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E9%99%90%E5%88%B6%E5%B9%B6%E5%8F%91%E6%95%B0%EF%BC%9F><span class=nav-number>9.3.8.</span> <span class=nav-text>8. 如何在协程中限制并发数？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#9-%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E5%8D%8F%E7%A8%8B%EF%BC%9F><span class=nav-number>9.3.9.</span> <span class=nav-text>9. 如何调试协程？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#10-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E5%8D%8F%E7%A8%8B%E6%80%A7%E8%83%BD%EF%BC%9F><span class=nav-number>9.3.10.</span> <span class=nav-text>10. 如何优化协程性能？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#11-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%EF%BC%9F><span class=nav-number>9.3.11.</span> <span class=nav-text>11. 如何在协程中处理异常？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#12-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%AE%9E%E7%8E%B0%E8%B6%85%E6%97%B6%EF%BC%9F><span class=nav-number>9.3.12.</span> <span class=nav-text>12. 如何在协程中实现超时？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#13-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%9F><span class=nav-number>9.3.13.</span> <span class=nav-text>13. 如何在协程中实现定时任务？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#14-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E4%BB%BB%E5%8A%A1%EF%BC%9F><span class=nav-number>9.3.14.</span> <span class=nav-text>14. 如何在协程中实现循环任务？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#15-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E9%99%90%E5%88%B6%EF%BC%9F><span class=nav-number>9.3.15.</span> <span class=nav-text>15. 如何在协程中实现并发限制？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#16-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F><span class=nav-number>9.3.16.</span> <span class=nav-text>16. 如何在协程中实现任务优先级？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#17-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E5%8F%96%E6%B6%88%EF%BC%9F><span class=nav-number>9.3.17.</span> <span class=nav-text>17. 如何在协程中实现任务取消？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#18-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E8%B6%85%E6%97%B6%EF%BC%9F><span class=nav-number>9.3.18.</span> <span class=nav-text>18. 如何在协程中实现任务超时？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#19-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%EF%BC%9F><span class=nav-number>9.3.19.</span> <span class=nav-text>19. 如何在协程中实现任务队列？</span></a></li><li class="nav-item nav-level-4"><a class=nav-link href=#20-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8F%E7%A8%8B%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E5%88%86%E7%BB%84%EF%BC%9F><span class=nav-number>9.3.20.</span> <span class=nav-text>20. 如何在协程中实现任务分组？</span></a></li></ol></li></ol></li></div></div></div></div></main><script src=/js/utils.js></script><script src=/js/header-shrink.js></script><script src=/js/back2top.js></script><script src=/js/toggle-theme.js></script><script src=/js/code-block.js></script><script src=/js/main.js></script><script src=/js/libs/anime.min.js></script><script src=/js/local-search.js></script><script src=/js/lazyload.js></script><div class=""><script src=/js/post/post-helper.js></script><script src=/js/post/toc.js></script><script src=/js/post/copyright-info.js></script><script src=/js/post/share.js></script><script defer=defer src=https://unpkg.com/mermaid/dist/mermaid.min.js></script><script>document.addEventListener("DOMContentLoaded",()=>{"undefined"!=typeof mermaid&&mermaid.initialize({startOnLoad:!0,theme:"dark"===document.documentElement.getAttribute("data-theme")?"dark":"default"})})</script></div></body></html>